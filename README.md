<details>
  <summary>LAB 1:  Writing a C program and comparing the outputs when compiling the code with both GCC and the RISC-V compiler</summary>
   

   **Let's write a simple C program to count numbers from 1 to N and compile it using GCC.**

Code to count numbers from 1 to 30:

![Screenshot 2024-07-17 134436](https://github.com/user-attachments/assets/a684f778-bf97-4889-a4ff-e30908945d56)

Output:

![Screenshot from 2024-07-17 14-54-39](https://github.com/user-attachments/assets/918f5dba-6b4c-448f-9fb3-0d8d7de4a4da)

**Now let's compile the same code using RISC-V**

![Screenshot from 2024-07-17 14-54-45](https://github.com/user-attachments/assets/63a713bf-d308-4f0a-aa7b-80d3b56fb300)

We open the object dumpfile using the command
```
riscv64-unknown-elf-objdump -d -sum1toN.o | less
```

![Screenshot from 2024-07-17 14-54-55](https://github.com/user-attachments/assets/8f09fa57-9167-4c6c-8f94-49de255c374a)

</details>



***



<details>
  <summary>LAB 2: Running the object file generated by the RISC-V compiler in the Spike Simulator, and performing debugging with the Spike Debugger</summary>
     
  In our previous lab, we compiled our C code using both gcc and a RISC-V compiler.
   
  ![Screenshot from 2024-07-20 14-17-33](https://github.com/user-attachments/assets/290c7134-0096-4802-84de-a00084905d32)

![Screenshot from 2024-07-20 14-20-11](https://github.com/user-attachments/assets/216bf957-e569-47a0-b448-0eeafaa4ba14)


Now, we will examine the output file generated by compiling the C code with the RISC-V compiler and debug the instructions.

Steps followed
1) Inspect the output generated by compiling the code with the gcc compiler, located in the file 'a.out'
2) Inspect the output generated by compiling the code with the RISC-V compiler, located in the file 'sum1toN.o'. and Check whether the outputs are the same or not
   
   ![Screenshot from 2024-07-20 14-18-57](https://github.com/user-attachments/assets/b971e17f-7aa8-4c52-9c0b-a1433c3e24a8)
   
4) Now we start debugging using the spike debugger
5) We will allow the Spike debugger to run until the main function, specifically until the **100b0** instruction. After that, we will manually continue debugging and inspect the **a0** register before and after the execution. We observe that the instruction **lui a0, 0x21** updates the a0 register from **0x0000000000000001** to **0x0000000000021000**
   
   ![Screenshot from 2024-07-20 15-10-29](https://github.com/user-attachments/assets/6928d9f4-c50e-4c29-a4df-28be34fb50b2)

6) Next, we will manually debug the next instruction  i.e., **addi sp, sp, -16**. This instruction decrements the stack pointer (sp) by 16. Before executing this instruction, the sp register held the value **0x0000003ffffffb50**, which is then updated to **0x0000003ffffffb40**

      ![Screenshot 2024-07-20 235518](https://github.com/user-attachments/assets/5efd476a-c03c-46d7-a20d-bd528eabd4f8)


The output appears at register 100b8, and it remains the same regardless of whether the code is executed using the gcc or riscv compilers.

### Now we will see the difference in the switches O1 and Ofast
![Screenshot from 2024-08-12 21-08-32](https://github.com/user-attachments/assets/4da34596-2b81-47bd-8cec-640ced76a240)

**assembly code with O1 switch:**
![Screenshot from 2024-08-12 21-04-25](https://github.com/user-attachments/assets/184e2ba2-683e-4e9e-8855-6d6dcbedf306)

**assembly code with Ofast switch:**
![Screenshot from 2024-08-12 21-06-22](https://github.com/user-attachments/assets/48583f24-095d-42f7-bee7-64d438ede310)

+ Number of instructions when compiled with O1 switch = 14
+ Number of instructions when compiled with Ofast switch = 11
+ We can observe that using the **-Ofast** optimization switch results in fewer assembly instructions compared to the **-O1** switch.

</details>



***



<details>
  <summary>LAB 3: 32-bit RISC-V Instruction Formats: Encoding, Simulation, and Waveform Analysis </summary>

  ## Task 1: RISC-V Instruction Formats and Hexadecimal Encoding of Specific Instructions
  ### Base Instruction Formats

  RISC-V has six core instruction formats: R, I, S, B, U, and J. These are all fixed 32 bits in length. Here is a brief description of each format:

  There are four core instruction formats (R/I/S/U), and there are a further two variants of the instruction formats (B/J) based on the handling of immediates.
  1. **R-Type (Register)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | funct7[31:25]
     + Used for register-register arithmetic and logical operations.
       ![Screenshot 2024-07-24 191623](https://github.com/user-attachments/assets/0bbb9695-b331-46e2-a75a-92a074344659)

  2. **I-Type (Immediate)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | imm[31:20]
     + Used for immediate arithmetic, logical operations, and load instructions.
       ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)

  3. **S-Type (Store)**
     + Format: opcode[6:0] | imm[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for store instructions.
       ![Screenshot 2024-07-24 191625](https://github.com/user-attachments/assets/446beff5-399d-4426-b868-0d9c6d2ef271)

  4. **U-Type (Upper Immediate)**
     + Format: opcode[6:0] | rd[11:7] | imm[31:12]
     + Used for instructions that operate with a 20-bit upper immediate, such as LUI (Load Upper Immediate).
        ![Screenshot 2024-07-24 191626](https://github.com/user-attachments/assets/60c0073d-2e33-4fbd-a54b-01a606aeb353)

  5. **B-Type (Branch)**
     + Format: opcode[6:0] | imm[11][7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for conditional branch instructions.
       ![Screenshot 2024-07-24 191847](https://github.com/user-attachments/assets/33c0c62f-3fe2-48bd-a1f5-18db951807cf)

  6. **J-Type (Jump)**
     + Format: opcode[6:0] | rd[11:7] | imm[19:12] | imm[31:20]
     + Used for jump instructions, such as JAL (Jump And Link).
       ![Screenshot 2024-07-24 191848](https://github.com/user-attachments/assets/7b2e93a1-1fc8-447f-95ed-1d34b82e8625)
       
RISC-V instruction types and the corresponding 32-bit instruction codes for the provided instructions:

1. ADD r9, r10, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0000000
   + rs1: 01010
   + rs2: 01011
   + rd: 01001
   + Instruction: 0000000 01011 01010 000 01001 0110011
     + 0x00B504B3
     
2. SUB r11, r9, r10
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0100000
   + rs1: 01001
   + rs2: 01010
   + rd: 01011
   + Instruction: 0100000	01010	01001	000	01011	0110011
     + 0x40A485B3
     
3. AND r10, r9, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 111
   + funct7: 0000000
   + rs1: 01001
   + rs2: 01011
   + rd: 01010
   + Instruction: 0000000	01011	01001	111	01010	0110011
     + 0x00B4F533
       
4. OR r8, r10, r5
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 110
   + funct7: 0000000
   + rs1: 01010
   + rs2: 00101
   + rd: 01000
   + Instruction: 0000000	00101	01010	110	01000	0110011
     + 0x00556433
     
5. XOR r8, r9, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 100
   + funct7: 0000000
   + rs1: 01001
   + rs2: 00100
   + rd: 01000
   + Instruction: 0000000	00100	01001	100	01000	0110011
     + 0x0044C433
     
6. SLT r0, r1, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 010
   + funct7: 0000000
   + rs1: 00001
   + rs2: 00100
   + rd: 00000
   + Instruction: 0000000	00100	00001	010	00000	0110011
     + 0x0040A033
     
7. ADDI r2, r2, 5
   + Type: I-Type
   + Opcode: 0010011
   + funct3: 000
   + Immediate: 000000000101
   + rs1: 00010
   + rd: 00010
   + Instruction: 000000000101	00010	000	00010	0010011
     + 0x00510113
     
8. SW r2, r0, 4
   + Type: S-Type
   + Opcode: 0100011
   + funct3: 010
   + Immediate: 000000000100
   + imm[11:5]: 0000000
   + imm[4:0]: 00100
   + rs1: 00000
   + rd: 00010
   + Instruction: 0000000	00010	00000	010	00100	0100011
     + 0x00202223
     
9. SRL r6, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 101
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00110
    + Instruction: 0000000	00001	00001	101	00110	0110011
      + 0x0010D333
      
10. BNE r0, r0, 20
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 001
    + Immediate: 000000010100
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1010
    + Instruction: 0 000000	00000	00000	001	1010 0	1100011
      + 0x00001A63
      
11. BEQ r0, r0, 15
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 000
    + Immediate: 000000001111
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1111
    + Instruction: 0 000000	00000	00000	000	1111 0	1100011
      + 0x00000F63
      
12. LW r3, r1, 2
    + Type: I-Type
    + Opcode: 0000011
    + funct3: 010
    + Immediate: 000000000010
    + rs1: 00001
    + rd: 00011
    + Instruction: 000000000010	00001	010	00011	0000011
      + 0x0020A183
      
13. SLL r5, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 001
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00101
    + Instruction: 0000000	00001	00001	001	00101	0110011
      + 0x001092B3
   
    | Instruction | Format |  Standard ISA Code |
    | :----------: | :------: | :------------------: |
    | ADD r9, r10, r11 | R | 0x00B504B3 |
    | SUB r11, r9, r10 | R | 0x40A485B3 |
    | AND r10, r9, r11 | R | 0x00B4F533 |
    | OR r8, r10, r5 | R | 0x00556433 |
    | XOR r8, r9, r4 | R | 0x0044C433 |
    | SLT r0, r1, r4 | R | 0x0040A033 |
    | ADDI r2, r2, 5 | I | 0x00510113 |
    | SW r2, r0, 4 | S | 0x00202223 |
    | SRL r6, r1, r1 | R | 0x0010D333 |
    | BNE r0, r0, 20 | B | 0x00001A63 |
    | BEQ r0, r0, 15 | B | 0x00000F63 |
    | LW r3, r1, 2 | I | 0x0020A183 |
    | SLL r5, r1, r1 | R | 0x001092B3 |

  ## Task 2: Simulation and Waveform analysis
  ### Steps to perform functional simulational
  1. Create two files in gedit as iiitb_rv32i.v and iiitb_rv32i_tb.v
  2. Copy the code from the reference github repository and paste it in your verilog and testbench files
  3. To run and simulate the verilog code in gtkwave, enter the following commands:
     ![Screenshot from 2024-07-28 18-34-21](https://github.com/user-attachments/assets/16c1874b-3d22-4eb4-b84c-5790071a1bff)

  **Following are the differences between standard RISCV ISA and Hardcoded ISA for the instruction set given in the reference repository:**  

  The standard RISC-V ISA for the given instructions can be generated in a manner similar to the approach we used in Task 1
  
  Hard-coded instructions: These are custom instructions where the bit patterns are manually set by the designer rather than adhering to the standard RISC-V specification. And they are designed for a specific purpose or application. Hence the 32-bits instruction that we generated will not match with the hardcoded ISA.
  
  
  |  **Instructions**  |  **Standard RISCV ISA**  |  **Hardcoded ISA**  |  
  |  :----:  |  :----:  |  :----:  |  
  |  ADD R6, R2, R1  |  32'h00110333  |  32'h02208300  |  
  |  SUB R7, R1, R2  |  32'h402083b3  |  32'h02209380  |  
  |  AND R8, R1, R3  |  32'h0030f433  |  32'h0230a400  |  
  |  OR R9, R2, R5  |  32'h005164b3  |  32'h02513480  |  
  |  XOR R10, R1, R4  |  32'h0040c533  |  32'h0240c500  |  
  |  SLT R1, R2, R4  |  32'h0045a0b3  |  32'h02415580  |  
  |  ADDI R12, R4, 5  |  32'h004120b3  |  32'h00520600  |  
  |  BEQ R0, R0, 15  |  32'h00000f63  |  32'h00f00002  |  
  |  SW R3, R1, 2  |  32'h0030a123  |  32'h00209181  |  
  |  LW R13, R1, 2  |  32'h0020a683  |  32'h00208681  |  
  |  SRL R16, R14, R2  |  32'h0030a123  |  32'h00271803  |
  |  SLL R15, R1, R2  |  32'h002097b3  |  32'h00208783  |  

  ### Analysing output waveforms of above given instructions:

  ```
  ADD R6, R2, R1
  ```
  ![IMG_0010](https://github.com/user-attachments/assets/30cb6411-4c2a-4a2b-9f43-430c505ac4e7)


  ```
  SUB R7, R1, R2
  ```
  ![IMG_0013](https://github.com/user-attachments/assets/aa230620-2c97-4abb-b0a3-96fd3995f3a8)

  
  ```
  AND R8, R1, R3
  ```
  ![IMG_0027](https://github.com/user-attachments/assets/cad8c2be-643e-431e-8579-460a29b6a59c)


  ```
  OR R9, R2, R5
  ```
  ![IMG_0016](https://github.com/user-attachments/assets/88b1edde-9b3d-4271-af0c-dac55c3300dc)


  ```
  XOR R10, R1, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/95486b24-2a92-4d3b-8f18-4c549ee5bf4f)


  ```
  SLT R1, R2, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/13e32a3b-a2e3-4105-9df3-1cf0fe0c60a4)


  ```
  ADDI R12, R4, 5
  ```
  ![IMG_0009](https://github.com/user-attachments/assets/8de296ea-9d55-4dba-9c89-738b470e5d97)


  ```
  BEQ R0, R0, 15
  ```
  ![IMG_0012](https://github.com/user-attachments/assets/a3c34a83-c1e6-4d80-bae5-f187535afc77)


 **5-Stage instruction pipeline**
 ![Screenshot from 2024-07-29 03-34-25](https://github.com/user-attachments/assets/f3e95dc9-f367-4cbb-ad81-0a73c286b899)

</details>


***



<details>
  <summary>LAB 4:  Selecting and Compiling a C Application with GCC and RISC-V GCC compiler</summary>
  
  ## Application Name: Logic Gate Simulator
  ### Overview: Simulates the behavior of basic logic gates (AND, OR, NOT, etc.) with truth tables and custom inputs
  **Logic Gate Simulator** is a C-based application designed to simulate the behavior of basic logic gates, including AND, OR, NOT, XOR, NAND, NOR. The application allows users to input custom values, generate truth tables

  **Code:**
  ```c
#include <stdio.h>

// Function prototypes for logic gates
int AND(int a, int b);
int OR(int a, int b);
int NOT(int a);
int XOR(int a, int b);
int NAND(int a, int b);
int NOR(int a, int b);

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name);

// Function to print the truth table for NOT gate
void print_truth_table_not();

// Main function
int main() {
    int choice;
    
    printf("Logic Gate Simulator\n");
    printf("1. AND Gate\n");
    printf("2. OR Gate\n");
    printf("3. NOT Gate\n");
    printf("4. XOR Gate\n");
    printf("5. NAND Gate\n");
    printf("6. NOR Gate\n");
    printf("Enter your choice (1-6): ");
    scanf("%d", &choice);

    switch(choice) {
        case 1:
            print_truth_table_two_inputs(AND, "AND");
            break;
        case 2:
            print_truth_table_two_inputs(OR, "OR");
            break;
        case 3:
            print_truth_table_not();
            break;
        case 4:
            print_truth_table_two_inputs(XOR, "XOR");
            break;
        case 5:
            print_truth_table_two_inputs(NAND, "NAND");
            break;
        case 6:
            print_truth_table_two_inputs(NOR, "NOR");
            break;
        default:
            printf("Invalid choice!\n");
    }

    return 0;
}

// AND gate function
int AND(int a, int b) {
    return a & b;
}

// OR gate function
int OR(int a, int b) {
    return a | b;
}

// NOT gate function
int NOT(int a) {
    return !a;
}

// XOR gate function
int XOR(int a, int b) {
    return a ^ b;
}

// NAND gate function
int NAND(int a, int b) {
    return !(a & b);
}

// NOR gate function
int NOR(int a, int b) {
    return !(a | b);
}

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name) {
    printf("\nTruth Table for %s Gate\n", gate_name);
    printf("A B | Output\n");
    printf("------------\n");

    for(int a = 0; a <= 1; a++) {
        for(int b = 0; b <= 1; b++) {
            printf("%d %d |   %d\n", a, b, gate(a, b));
        }
    }
}

// Function to print the truth table for NOT gate
void print_truth_table_not() {
    printf("\nTruth Table for NOT Gate\n");
    printf("A | Output\n");
    printf("---------\n");

    for(int a = 0; a <= 1; a++) {
        printf("%d |   %d\n", a, NOT(a));
    }
}
```

**Compiling the application using the GCC compiler:**

![Screenshot from 2024-08-14 20-17-59](https://github.com/user-attachments/assets/5aa3c864-798a-468e-a0ff-294b7c522f0b)


**Compiling the application using the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-18-56](https://github.com/user-attachments/assets/6264cabc-ee3d-4e84-8906-1fc4b3fb76a3)

**Comparing the output of the application when compiled with the standard GCC compiler versus the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-19-49](https://github.com/user-attachments/assets/31633f1a-5c3c-480a-97f6-85663384a5d2)







</details>






