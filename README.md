<details>
  <summary>LAB 1:  Writing a C program and comparing the outputs when compiling the code with both GCC and the RISC-V compiler</summary>
   

   **Let's write a simple C program to count numbers from 1 to N and compile it using GCC.**

Code to count numbers from 1 to 30:

![Screenshot 2024-07-17 134436](https://github.com/user-attachments/assets/a684f778-bf97-4889-a4ff-e30908945d56)

Output:

![Screenshot from 2024-07-17 14-54-39](https://github.com/user-attachments/assets/918f5dba-6b4c-448f-9fb3-0d8d7de4a4da)

**Now let's compile the same code using RISC-V**

![Screenshot from 2024-07-17 14-54-45](https://github.com/user-attachments/assets/63a713bf-d308-4f0a-aa7b-80d3b56fb300)

We open the object dumpfile using the command
```
riscv64-unknown-elf-objdump -d -sum1toN.o | less
```

![Screenshot from 2024-07-17 14-54-55](https://github.com/user-attachments/assets/8f09fa57-9167-4c6c-8f94-49de255c374a)

</details>



***



<details>
  <summary>LAB 2: Running the object file generated by the RISC-V compiler in the Spike Simulator, and performing debugging with the Spike Debugger</summary>
     
  In our previous lab, we compiled our C code using both gcc and a RISC-V compiler.
   
  ![Screenshot from 2024-07-20 14-17-33](https://github.com/user-attachments/assets/290c7134-0096-4802-84de-a00084905d32)

![Screenshot from 2024-07-20 14-20-11](https://github.com/user-attachments/assets/216bf957-e569-47a0-b448-0eeafaa4ba14)


Now, we will examine the output file generated by compiling the C code with the RISC-V compiler and debug the instructions.

Steps followed
1) Inspect the output generated by compiling the code with the gcc compiler, located in the file 'a.out'
2) Inspect the output generated by compiling the code with the RISC-V compiler, located in the file 'sum1toN.o'. and Check whether the outputs are the same or not
   
   ![Screenshot from 2024-07-20 14-18-57](https://github.com/user-attachments/assets/b971e17f-7aa8-4c52-9c0b-a1433c3e24a8)
   
4) Now we start debugging using the spike debugger
5) We will allow the Spike debugger to run until the main function, specifically until the **100b0** instruction. After that, we will manually continue debugging and inspect the **a0** register before and after the execution. We observe that the instruction **lui a0, 0x21** updates the a0 register from **0x0000000000000001** to **0x0000000000021000**
   
   ![Screenshot from 2024-07-20 15-10-29](https://github.com/user-attachments/assets/6928d9f4-c50e-4c29-a4df-28be34fb50b2)

6) Next, we will manually debug the next instruction  i.e., **addi sp, sp, -16**. This instruction decrements the stack pointer (sp) by 16. Before executing this instruction, the sp register held the value **0x0000003ffffffb50**, which is then updated to **0x0000003ffffffb40**

      ![Screenshot 2024-07-20 235518](https://github.com/user-attachments/assets/5efd476a-c03c-46d7-a20d-bd528eabd4f8)

The output appears at register 100b8, and it remains the same regardless of whether the code is executed using the gcc or riscv compilers.

### Now we will see the difference in the switches O1 and Ofast
![Screenshot from 2024-08-12 21-08-32](https://github.com/user-attachments/assets/4da34596-2b81-47bd-8cec-640ced76a240)

**assembly code with O1 switch:**
![Screenshot from 2024-08-12 21-04-25](https://github.com/user-attachments/assets/184e2ba2-683e-4e9e-8855-6d6dcbedf306)

**assembly code with Ofast switch:**
![Screenshot from 2024-08-12 21-06-22](https://github.com/user-attachments/assets/48583f24-095d-42f7-bee7-64d438ede310)

+ Number of instructions when compiled with O1 switch = 14
+ Number of instructions when compiled with Ofast switch = 11
+ We can observe that using the **-Ofast** optimization switch results in fewer assembly instructions compared to the **-O1** switch.

</details>



***



<details>
  <summary>LAB 3: 32-bit RISC-V Instruction Formats: Encoding, Simulation, and Waveform Analysis </summary>

  ## Task 1: RISC-V Instruction Formats and Hexadecimal Encoding of Specific Instructions
  ### Base Instruction Formats

  RISC-V has six core instruction formats: R, I, S, B, U, and J. These are all fixed 32 bits in length. Here is a brief description of each format:

  There are four core instruction formats (R/I/S/U), and there are a further two variants of the instruction formats (B/J) based on the handling of immediates.
  1. **R-Type (Register)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | funct7[31:25]
     + Used for register-register arithmetic and logical operations.
       ![Screenshot 2024-07-24 191623](https://github.com/user-attachments/assets/0bbb9695-b331-46e2-a75a-92a074344659)

  2. **I-Type (Immediate)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | imm[31:20]
     + Used for immediate arithmetic, logical operations, and load instructions.
       ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)

  3. **S-Type (Store)**
     + Format: opcode[6:0] | imm[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for store instructions.
       ![Screenshot 2024-07-24 191625](https://github.com/user-attachments/assets/446beff5-399d-4426-b868-0d9c6d2ef271)

  4. **U-Type (Upper Immediate)**
     + Format: opcode[6:0] | rd[11:7] | imm[31:12]
     + Used for instructions that operate with a 20-bit upper immediate, such as LUI (Load Upper Immediate).
        ![Screenshot 2024-07-24 191626](https://github.com/user-attachments/assets/60c0073d-2e33-4fbd-a54b-01a606aeb353)

  5. **B-Type (Branch)**
     + Format: opcode[6:0] | imm[11][7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for conditional branch instructions.
       ![Screenshot 2024-07-24 191847](https://github.com/user-attachments/assets/33c0c62f-3fe2-48bd-a1f5-18db951807cf)

  6. **J-Type (Jump)**
     + Format: opcode[6:0] | rd[11:7] | imm[19:12] | imm[31:20]
     + Used for jump instructions, such as JAL (Jump And Link).
       ![Screenshot 2024-07-24 191848](https://github.com/user-attachments/assets/7b2e93a1-1fc8-447f-95ed-1d34b82e8625)
       
RISC-V instruction types and the corresponding 32-bit instruction codes for the provided instructions:

1. ADD r9, r10, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0000000
   + rs1: 01010
   + rs2: 01011
   + rd: 01001
   + Instruction: 0000000 01011 01010 000 01001 0110011
     + 0x00B504B3
     
2. SUB r11, r9, r10
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0100000
   + rs1: 01001
   + rs2: 01010
   + rd: 01011
   + Instruction: 0100000	01010	01001	000	01011	0110011
     + 0x40A485B3
     
3. AND r10, r9, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 111
   + funct7: 0000000
   + rs1: 01001
   + rs2: 01011
   + rd: 01010
   + Instruction: 0000000	01011	01001	111	01010	0110011
     + 0x00B4F533
       
4. OR r8, r10, r5
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 110
   + funct7: 0000000
   + rs1: 01010
   + rs2: 00101
   + rd: 01000
   + Instruction: 0000000	00101	01010	110	01000	0110011
     + 0x00556433
     
5. XOR r8, r9, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 100
   + funct7: 0000000
   + rs1: 01001
   + rs2: 00100
   + rd: 01000
   + Instruction: 0000000	00100	01001	100	01000	0110011
     + 0x0044C433
     
6. SLT r0, r1, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 010
   + funct7: 0000000
   + rs1: 00001
   + rs2: 00100
   + rd: 00000
   + Instruction: 0000000	00100	00001	010	00000	0110011
     + 0x0040A033
     
7. ADDI r2, r2, 5
   + Type: I-Type
   + Opcode: 0010011
   + funct3: 000
   + Immediate: 000000000101
   + rs1: 00010
   + rd: 00010
   + Instruction: 000000000101	00010	000	00010	0010011
     + 0x00510113
     
8. SW r2, r0, 4
   + Type: S-Type
   + Opcode: 0100011
   + funct3: 010
   + Immediate: 000000000100
   + imm[11:5]: 0000000
   + imm[4:0]: 00100
   + rs1: 00000
   + rd: 00010
   + Instruction: 0000000	00010	00000	010	00100	0100011
     + 0x00202223
     
9. SRL r6, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 101
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00110
    + Instruction: 0000000	00001	00001	101	00110	0110011
      + 0x0010D333
      
10. BNE r0, r0, 20
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 001
    + Immediate: 000000010100
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1010
    + Instruction: 0 000000	00000	00000	001	1010 0	1100011
      + 0x00001A63
      
11. BEQ r0, r0, 15
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 000
    + Immediate: 000000001111
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1111
    + Instruction: 0 000000	00000	00000	000	1111 0	1100011
      + 0x00000F63
      
12. LW r3, r1, 2
    + Type: I-Type
    + Opcode: 0000011
    + funct3: 010
    + Immediate: 000000000010
    + rs1: 00001
    + rd: 00011
    + Instruction: 000000000010	00001	010	00011	0000011
      + 0x0020A183
      
13. SLL r5, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 001
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00101
    + Instruction: 0000000	00001	00001	001	00101	0110011
      + 0x001092B3
   
    | Instruction | Format |  Standard ISA Code |
    | :----------: | :------: | :------------------: |
    | ADD r9, r10, r11 | R | 0x00B504B3 |
    | SUB r11, r9, r10 | R | 0x40A485B3 |
    | AND r10, r9, r11 | R | 0x00B4F533 |
    | OR r8, r10, r5 | R | 0x00556433 |
    | XOR r8, r9, r4 | R | 0x0044C433 |
    | SLT r0, r1, r4 | R | 0x0040A033 |
    | ADDI r2, r2, 5 | I | 0x00510113 |
    | SW r2, r0, 4 | S | 0x00202223 |
    | SRL r6, r1, r1 | R | 0x0010D333 |
    | BNE r0, r0, 20 | B | 0x00001A63 |
    | BEQ r0, r0, 15 | B | 0x00000F63 |
    | LW r3, r1, 2 | I | 0x0020A183 |
    | SLL r5, r1, r1 | R | 0x001092B3 |

  ## Task 2: Simulation and Waveform analysis
  ### Steps to perform functional simulational
  1. Create two files in gedit as iiitb_rv32i.v and iiitb_rv32i_tb.v
  2. Copy the code from the reference github repository and paste it in your verilog and testbench files
  3. To run and simulate the verilog code in gtkwave, enter the following commands:
     ![Screenshot from 2024-07-28 18-34-21](https://github.com/user-attachments/assets/16c1874b-3d22-4eb4-b84c-5790071a1bff)

  **Following are the differences between standard RISCV ISA and Hardcoded ISA for the instruction set given in the reference repository:**  

  The standard RISC-V ISA for the given instructions can be generated in a manner similar to the approach we used in Task 1
  
  Hard-coded instructions: These are custom instructions where the bit patterns are manually set by the designer rather than adhering to the standard RISC-V specification. And they are designed for a specific purpose or application. Hence the 32-bits instruction that we generated will not match with the hardcoded ISA.
  
  
  |  **Instructions**  |  **Standard RISCV ISA**  |  **Hardcoded ISA**  |  
  |  :----:  |  :----:  |  :----:  |  
  |  ADD R6, R2, R1  |  32'h00110333  |  32'h02208300  |  
  |  SUB R7, R1, R2  |  32'h402083b3  |  32'h02209380  |  
  |  AND R8, R1, R3  |  32'h0030f433  |  32'h0230a400  |  
  |  OR R9, R2, R5  |  32'h005164b3  |  32'h02513480  |  
  |  XOR R10, R1, R4  |  32'h0040c533  |  32'h0240c500  |  
  |  SLT R1, R2, R4  |  32'h0045a0b3  |  32'h02415580  |  
  |  ADDI R12, R4, 5  |  32'h004120b3  |  32'h00520600  |  
  |  BEQ R0, R0, 15  |  32'h00000f63  |  32'h00f00002  |  
  |  SW R3, R1, 2  |  32'h0030a123  |  32'h00209181  |  
  |  LW R13, R1, 2  |  32'h0020a683  |  32'h00208681  |  
  |  SRL R16, R14, R2  |  32'h0030a123  |  32'h00271803  |
  |  SLL R15, R1, R2  |  32'h002097b3  |  32'h00208783  |  

  ### Analysing output waveforms of above given instructions:

  ```
  ADD R6, R2, R1
  ```
  ![IMG_0010](https://github.com/user-attachments/assets/30cb6411-4c2a-4a2b-9f43-430c505ac4e7)


  ```
  SUB R7, R1, R2
  ```
  ![IMG_0013](https://github.com/user-attachments/assets/aa230620-2c97-4abb-b0a3-96fd3995f3a8)

  
  ```
  AND R8, R1, R3
  ```
  ![IMG_0027](https://github.com/user-attachments/assets/cad8c2be-643e-431e-8579-460a29b6a59c)


  ```
  OR R9, R2, R5
  ```
  ![IMG_0016](https://github.com/user-attachments/assets/88b1edde-9b3d-4271-af0c-dac55c3300dc)


  ```
  XOR R10, R1, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/95486b24-2a92-4d3b-8f18-4c549ee5bf4f)


  ```
  SLT R1, R2, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/13e32a3b-a2e3-4105-9df3-1cf0fe0c60a4)


  ```
  ADDI R12, R4, 5
  ```
  ![IMG_0009](https://github.com/user-attachments/assets/8de296ea-9d55-4dba-9c89-738b470e5d97)


  ```
  BEQ R0, R0, 15
  ```
  ![IMG_0012](https://github.com/user-attachments/assets/a3c34a83-c1e6-4d80-bae5-f187535afc77)


 **5-Stage instruction pipeline**
 ![Screenshot from 2024-07-29 03-34-25](https://github.com/user-attachments/assets/f3e95dc9-f367-4cbb-ad81-0a73c286b899)

</details>


***



<details>
  <summary>LAB 4:  Selecting and Compiling a C Application with GCC and RISC-V GCC compiler</summary>
  
  ## Application Name: Logic Gate Simulator
  ### Overview: Simulates the behavior of basic logic gates (AND, OR, NOT, etc.) with truth tables and custom inputs
  **Logic Gate Simulator** is a C-based application designed to simulate the behavior of basic logic gates, including AND, OR, NOT, XOR, NAND, NOR. The application allows users to input custom values, generate truth tables

  **Code:**
  ```c
#include <stdio.h>

// Function prototypes for logic gates
int AND(int a, int b);
int OR(int a, int b);
int NOT(int a);
int XOR(int a, int b);
int NAND(int a, int b);
int NOR(int a, int b);

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name);

// Function to print the truth table for NOT gate
void print_truth_table_not();

// Main function
int main() {
    int choice;
    
    printf("Logic Gate Simulator\n");
    printf("1. AND Gate\n");
    printf("2. OR Gate\n");
    printf("3. NOT Gate\n");
    printf("4. XOR Gate\n");
    printf("5. NAND Gate\n");
    printf("6. NOR Gate\n");
    printf("Enter your choice (1-6): ");
    scanf("%d", &choice);

    switch(choice) {
        case 1:
            print_truth_table_two_inputs(AND, "AND");
            break;
        case 2:
            print_truth_table_two_inputs(OR, "OR");
            break;
        case 3:
            print_truth_table_not();
            break;
        case 4:
            print_truth_table_two_inputs(XOR, "XOR");
            break;
        case 5:
            print_truth_table_two_inputs(NAND, "NAND");
            break;
        case 6:
            print_truth_table_two_inputs(NOR, "NOR");
            break;
        default:
            printf("Invalid choice!\n");
    }

    return 0;
}

// AND gate function
int AND(int a, int b) {
    return a & b;
}

// OR gate function
int OR(int a, int b) {
    return a | b;
}

// NOT gate function
int NOT(int a) {
    return !a;
}

// XOR gate function
int XOR(int a, int b) {
    return a ^ b;
}

// NAND gate function
int NAND(int a, int b) {
    return !(a & b);
}

// NOR gate function
int NOR(int a, int b) {
    return !(a | b);
}

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name) {
    printf("\nTruth Table for %s Gate\n", gate_name);
    printf("A B | Output\n");
    printf("------------\n");

    for(int a = 0; a <= 1; a++) {
        for(int b = 0; b <= 1; b++) {
            printf("%d %d |   %d\n", a, b, gate(a, b));
        }
    }
}

// Function to print the truth table for NOT gate
void print_truth_table_not() {
    printf("\nTruth Table for NOT Gate\n");
    printf("A | Output\n");
    printf("---------\n");

    for(int a = 0; a <= 1; a++) {
        printf("%d |   %d\n", a, NOT(a));
    }
}
```

**Compiling the application using the GCC compiler:**

![Screenshot from 2024-08-14 20-17-59](https://github.com/user-attachments/assets/5aa3c864-798a-468e-a0ff-294b7c522f0b)


**Compiling the application using the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-18-56](https://github.com/user-attachments/assets/6264cabc-ee3d-4e84-8906-1fc4b3fb76a3)

**Comparing the output of the application when compiled with the standard GCC compiler versus the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-19-49](https://github.com/user-attachments/assets/31633f1a-5c3c-480a-97f6-85663384a5d2)


</details>


***


<details>
  <summary>LAB 5: 5 Stage Pipelined RISC-V Processor </summary>
  
**TL-Verilog** is a higher-level version of Verilog used for modeling and designing digital systems in a more abstract way. Instead of focusing on the detailed wiring and gates, TL-Verilog lets you describe how a system behaves without getting into the specifics of its implementation. This abstraction is useful for system-level design and simulation.

**Makerchip** is an online platform where you can design, simulate, and test digital systems using HDLs like TL-Verilog, Verilog, and VHDL. It offers a user-friendly environment for creating and experimenting with digital designs, making it great for learning, teaching, and prototyping. 
  
  <details>
    <summary> Digital Logic with TL-Verilog and Makerchip </summary>
Logic gates are essential parts of digital circuits. They perform basic operations on binary data (0s and 1s) and are key to how computers and other digital devices handle information. There are different types of logic gates, each with a specific function
    
  ![Screenshot (219)](https://github.com/user-attachments/assets/37dc2892-d103-4f6c-9e1c-d6bcde83cfd1)
  ![Screenshot (220)](https://github.com/user-attachments/assets/042668ea-4aea-4698-9850-4742b14bc3a1)
    
  ### Combinational Logic in TL-Verilog and Makerchip
  
  Combinational logic involves creating circuits that process binary inputs to produce binary outputs based on set rules. These circuits operate without memory or feedback, meaning their outputs depend only on the current inputs and not on past states.
  
  **1) Inverter on Makerchip**
     ![Screenshot (209)](https://github.com/user-attachments/assets/73a65273-f58c-47cb-b0cd-08f38ab66bcf)     
  **2) AND gate on Makerchip**
     ![Screenshot (210)](https://github.com/user-attachments/assets/2aef5ed9-377a-43ef-b8c6-f9525a4be4e6)
  **3) OR gate on Makerchip**
     ![Screenshot (212)](https://github.com/user-attachments/assets/afef06d7-b4cd-4ab9-a014-12672f220c2a)
  **4) EXOR gate on Makerchip**
     ![Screenshot (213)](https://github.com/user-attachments/assets/ce40afa4-ddec-4918-bfa8-67600cb20964)
  **5) Vectors on Makerchip**
     ![Screenshot (214)](https://github.com/user-attachments/assets/3c5081a4-eddd-4544-b6c7-3280bf8cd100)
  **6) Mux on Makerchip**
     ![Screenshot (215)](https://github.com/user-attachments/assets/3a3b02c7-be90-41f5-b290-6b03b845eb67)
     ![Screenshot (216)](https://github.com/user-attachments/assets/9b687af5-a899-4641-9be3-7d33632490c0)
  **7) Calculator on Makerchip**
  ```c
\TLV
   $reset = *reset;
   
   $val1[31:0] = $rand1[3:0];
   $val2[31:0] = $rand2[3:0];
   $sum[31:0]  = $val1[31:0] + $val2[31:0];
   $diff[31:0] = $val1[31:0] - $val2[31:0];
   $prod[31:0] = $val1[31:0] * $val2[31:0];
   $quot[31:0] = $val1[31:0] / $val2[31:0];
   
   $out[31:0] = $op[1] ? ($op[0] ? $quot[31:0] : $prod[31:0]) : ($op[0] ? $diff[31:0] : $add[31:0]); 
  ```

  ![Screenshot (218)](https://github.com/user-attachments/assets/d97dcefb-635b-4c5d-91b5-6338297be285)


  ### Sequential Logic in TL-Verilog and Makerchip
  Sequential logic is a type of digital circuit where the output depends on both the current inputs and the circuit's previous states. Unlike combinational logic, which only uses current inputs to produce outputs, sequential logic includes memory elements to keep track of past information and influence the current output.
  
**1) Sequential calculator on Makerchip**
![Screenshot (222)](https://github.com/user-attachments/assets/9d23930c-9b12-4529-8c0f-14c59fd0da43)


  ```c
\TLV
   |calc
      @1
         $clk_lik = *clk;
         $reset = *reset;
         $val1[31:0] = >>1$result[31:0];
         $val2[31:0] = $rand2[3:0];
         $result[31:0] = $reset ? 32'b0 : ($sel[1:0] == 2'b00)
                         ? ($val1[31:0] + $val2[31:0]) : ($sel[1:0] == 2'b01)
                         ? ($val1[31:0] - $val2[31:0]) : ($sel[1:0] == 2'b10)
                         ? ($val1[31:0] * $val2[31:0]) : ($sel[1:0] == 2'b11)
                         ? ($val2[31:0] != 0 ? ($val1[31:0] / $val2[31:0]) : 32'bx) :  32'b0;
 ```

  ![Screenshot (221)](https://github.com/user-attachments/assets/10f9e7de-4be1-4d33-9103-3adacdd45b3c)


  ### Pipelined Logic
  
Pipelining is a key feature in TL-Verilog that simplifies coding and helps reduce bugs compared to SystemVerilog. In TL-Verilog, you can easily implement pipelining with less code. For example, in the provided repo, you can see how pipelining is used to calculate the Pythagorean theorem. In TL-Verilog, you define the pipeline stages using |calc and align them with @1, @2, and so on.



**2-Cycle Calculator in Pipeline**

![Screenshot (226)](https://github.com/user-attachments/assets/d4c28f9f-d80b-4618-99fe-d1c3f7e7626e)


```c
\TLV
   |calc
      @1
         $reset = *reset;
         $clk_lik = *clk;
         $val1[31:0] = >>2$out[31:0];
         $val2[31:0] = $rand2[3:0];
         $op[1:0] = $rand3[1:0];
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         
         $num = $reset ? 0 : >>1$num+1;
      @2   
         $out[31:0] = ($reset|!$num) ? 32'b0 : (($op[1:0]==2'b00) ? $sum :
                                       ($op[1:0]==2'b01) ? $diff :
                                          ($op[1:0]==2'b10) ? $prod : $quot);
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
```
![Screenshot (227)](https://github.com/user-attachments/assets/4ba5d5df-4b1b-4767-aac9-d618c337afca)


  ### Validity
  **1) 2-Cycle Calculator with Validity**
  
  ![Screenshot (233)](https://github.com/user-attachments/assets/eb5d65f4-1688-4bba-b263-9a4078c43be6)

  ```c
\TLV
    |calc
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
      @1
         $val1 [31:0] = >>2$out;
         $val2 [31:0] = $rand2[3:0];
         
         $valid = $reset ? 1'b0 : >>1$valid + 1'b1 ;
         $valid_or_reset = $valid || $reset;
         
      ?$vaild_or_reset
         @1   
            $sum [31:0] = $val1 + $val2;
            $diff[31:0] = $val1 - $val2;
            $prod[31:0] = $val1 * $val2;
            $quot[31:0] = $val1 / $val2;
            
         @2   
            $mem[31:0] = $reset ? 32'b0 :
                         ($op[2:0] == 3'b101) ? $val1 : >>2$mem ;
            
            $out [31:0] = $reset ? 32'b0 :
                          ($op[2:0] == 3'b000) ? $sum :
                          ($op[2:0] == 3'b001) ? $diff :
                          ($op[2:0] == 3'b010) ? $prod :
                          ($op[2:0] == 3'b011) ? $quot :
                          ($op[2:0] == 3'b100) ? >>2$mem : >>2$out ;
  ```
![Screenshot (234)](https://github.com/user-attachments/assets/1b1824fc-60f2-42d6-99fb-ae8fc9a00eae)


  **2) Calculator with single value memory**
  
![Screenshot (236)](https://github.com/user-attachments/assets/4f59abf9-15e6-48b5-b579-4924577dfc63)
```c
\TLV
    |calc
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
      @1
         $val1 [31:0] = >>2$out;
         $val2 [31:0] = $rand2[3:0];
         
         $valid = $reset ? 1'b0 : >>1$valid + 1'b1 ;
         $valid_or_reset = $valid || $reset;
         
      ?$vaild_or_reset
         @1   
            $sum [31:0] = $val1 + $val2;
            $diff[31:0] = $val1 - $val2;
            $prod[31:0] = $val1 * $val2;
            $quot[31:0] = $val1 / $val2;
            
         @2   
            $mem[31:0] = $reset ? 32'b0 :
                         ($op[2:0] == 3'b101) ? $val1 : >>2$mem ;
            
            $out [31:0] = $reset ? 32'b0 :
                          ($op[2:0] == 3'b000) ? $sum :
                          ($op[2:0] == 3'b001) ? $diff :
                          ($op[2:0] == 3'b010) ? $prod :
                          ($op[2:0] == 3'b011) ? $quot :
                          ($op[2:0] == 3'b100) ? >>2$mem : >>2$out ;
```
![Screenshot (237)](https://github.com/user-attachments/assets/9195b7f4-1db3-4afe-ab27-482f80ef35f4)

  </details>

  
  <details>
    <summary> Basic RISC-V CPU micro-architecture </summary>
    
  ### Introduction to Simple RISC-V micro-architecture 
  RISC-V block diagram A block diagram of a RISC-V processor provides a high-level overview of its major components and how they are interconnected. Here's a block diagram of a typical RISC-V processor:

  + **Decoder:** The decoder translates binary instructions into control signals that direct the processor's functional units on how to execute them.
  + **Instruction Memory:** Instruction memory stores and supplies the machine instructions needed by the processor for execution.
  + **ALU (Arithmetic Logic Unit):** The ALU performs arithmetic and logical operations on data, such as addition and comparisons.
  + **ALU Control Unit:** The ALU control unit provides signals to configure the ALU for the specific operation required by the current instruction.
  + **Register File:** The register file contains general-purpose registers that temporarily store data during instruction execution.
  + **Data Memory:** Data memory holds data for read and write operations and is used in load and store instructions.

  ### Fetch and Decode
  
  

  ### RISC-V Control logic

  </details>


  <details>
    <summary> Complete Pipelined RISC-V CPU micro-architecture </summary>
    
  ### RISCV core with Pipeline
  ```c
\m4_TLV_version 1d: tl-x.org
\SV
   // Template code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 10000)           // Store r10 result in dmem
   m4_asm(LW, r17, r0, 10000)           // Load contents of dmem to r17
   m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
         //PC fetch - branch, jumps and loads introduce 2 cycle bubbles in this pipeline
         $pc[31:0] = >>1$reset ? '0 : (>>3$valid_taken_br ? >>3$br_tgt_pc :
                                       >>3$valid_load     ? >>3$inc_pc[31:0] :
                                       >>3$jal_valid      ? >>3$br_tgt_pc :
                                       >>3$jalr_valid     ? >>3$jalr_tgt_pc :
                                                     (>>1$inc_pc[31:0]));
         // Access instruction memory using PC
         $imem_rd_en = ~ $reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         
         
      @1
         //Getting instruction from IMem
         $instr[31:0] = $imem_rd_data[31:0];
         
         //Increment PC
         $inc_pc[31:0] = $pc[31:0] + 32'h4;
         
         //Decoding I,R,S,U,B,J type of instructions based on opcode [6:0]
         //Only [6:2] is used here because this implementation is for RV64I which does not use [1:0]
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $is_j_instr = $instr[6:2] == 5'b11011;
         
         //Immediate value decode
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}} , $instr[30:20]} :
                      $is_s_instr ? { {21{$instr[31]}} , $instr[30:25] , $instr[11:8] , $instr[7]} :
                      $is_b_instr ? { {20{$instr[31]}} , $instr[7] , $instr[30:25] , $instr[11:8] , 1'b0} :
                      $is_u_instr ? { $instr[31] , $instr[30:12] , { 12{1'b0}} } :
                      $is_j_instr ? { {12{$instr[31]}} , $instr[19:12] , $instr[20] , $instr[30:21] , 1'b0} :
                      >>1$imm[31:0];
         
         //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
         
         //Decode other fields of instruction - source and destination registers, funct, opcode
         ?$rs1_or_funct3_valid
            $rs1[4:0]    = $instr[19:15];
            $funct3[2:0] = $instr[14:12];
         
         ?$rs2_valid
            $rs2[4:0]    = $instr[24:20];
         
         ?$rd_valid
            $rd[4:0]     = $instr[11:7];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         //Decode instruction in subset of base instruction set based on RISC-V 32I
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         //Branch instructions
         $is_beq   = $dec_bits ==? 11'bx_000_1100011;
         $is_bne   = $dec_bits ==? 11'bx_001_1100011;
         $is_blt   = $dec_bits ==? 11'bx_100_1100011;
         $is_bge   = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu  = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu  = $dec_bits ==? 11'bx_111_1100011;
         
         //Jump instructions
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal   = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr  = $dec_bits ==? 11'bx_000_1100111;
         
         //Arithmetic instructions
         $is_addi  = $dec_bits ==? 11'bx_000_0010011;
         $is_add   = $dec_bits ==  11'b0_000_0110011;
         $is_lui   = $dec_bits ==? 11'bx_xxx_0110111;
         $is_slti  = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori  = $dec_bits ==? 11'bx_100_0010011;
         $is_ori   = $dec_bits ==? 11'bx_110_0010011;
         $is_andi  = $dec_bits ==? 11'bx_111_0010011;
         $is_slli  = $dec_bits ==? 11'b0_001_0010011;
         $is_srli  = $dec_bits ==? 11'b0_101_0010011;
         $is_srai  = $dec_bits ==? 11'b1_101_0010011;
         $is_sub   = $dec_bits ==? 11'b1_000_0110011;
         $is_sll   = $dec_bits ==? 11'b0_001_0110011;
         $is_slt   = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu  = $dec_bits ==? 11'b0_011_0110011;
         $is_xor   = $dec_bits ==? 11'b0_100_0110011;
         $is_srl   = $dec_bits ==? 11'b0_101_0110011;
         $is_sra   = $dec_bits ==? 11'b1_101_0110011;
         $is_or    = $dec_bits ==? 11'b0_110_0110011;
         $is_and   = $dec_bits ==? 11'b0_111_0110011;
         
         //Store instructions
         $is_sb    = $dec_bits ==? 11'bx_000_0100011;
         $is_sh    = $dec_bits ==? 11'bx_001_0100011;
         $is_sw    = $dec_bits ==? 11'bx_010_0100011;
         
         //Load instructions - support only 4 byte load
         $is_load  = $dec_bits ==? 11'bx_xxx_0000011;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         //Get Source register values from reg file
         $rf_rd_en1 = $rs1_or_funct3_valid;
         $rf_rd_en2 = $rs2_valid;
         
         $rf_rd_index1[4:0] = $rs1[4:0];
         $rf_rd_index2[4:0] = $rs2[4:0];
         
         //Register file bypass logic - data forwarding from ALU to resolve RAW dependence
         $src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
         $src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
         
         //Branch target PC computation for branches and JAL
         $br_tgt_pc[31:0] = $imm[31:0] + $pc[31:0];
         
         //RAW dependence check for ALU data forwarding
         //If previous instruction was writing to reg file, and current instruction is reading from same register
         $rs1_bypass = >>1$rf_wr_en && (>>1$rd == $rs1);
         $rs2_bypass = >>1$rf_wr_en && (>>1$rd == $rs2);
         
      @3
         //ALU
         $result[31:0] = $is_addi  ? $src1_value +  $imm :
                         $is_add   ? $src1_value +  $src2_value :
                         $is_andi  ? $src1_value &  $imm :
                         $is_ori   ? $src1_value |  $imm :
                         $is_xori  ? $src1_value ^  $imm :
                         $is_slli  ? $src1_value << $imm[5:0]:
                         $is_srli  ? $src1_value >> $imm[5:0]:
                         $is_and   ? $src1_value &  $src2_value:
                         $is_or    ? $src1_value |  $src2_value:
                         $is_xor   ? $src1_value ^  $src2_value:
                         $is_sub   ? $src1_value -  $src2_value:
                         $is_sll   ? $src1_value << $src2_value:
                         $is_srl   ? $src1_value >> $src2_value:
                         $is_sltu  ? $sltu_rslt[31:0]:
                         $is_sltiu ? $sltiu_rslt[31:0]:
                         $is_lui   ? {$imm[31:12], 12'b0}:
                         $is_auipc ? $pc + $imm:
                         $is_jal   ? $pc + 4:
                         $is_jalr  ? $pc + 4:
                         $is_srai  ? ({ {32{$src1_value[31]}} , $src1_value} >> $imm[4:0]) :
                         $is_slt   ? (($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]}):
                         $is_slti  ? (($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]}) :
                         $is_sra   ? ({ {32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $is_load  ? $src1_value +  $imm :
                         $is_s_instr ? $src1_value + $imm :
                                    32'bx;
         
         $sltu_rslt[31:0]  = $src1_value <  $src2_value;
         $sltiu_rslt[31:0] = $src1_value <  $imm;
         
         //Jump instruction target PC computation
         $jalr_tgt_pc[31:0] = $imm[31:0] + $src1_value[31:0]; 
         
         //Branch resolution
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
         $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid || >>1$jump_valid);
         
         //Current instruction is valid & is a taken branch
         $valid_taken_br = $valid && $taken_br;
         
         //Current instruction is valid & is a load
         $valid_load = $valid && $is_load;
         
         //Current instruction is valid & is jump
         $jump_valid = $valid && $is_jump;
         $jal_valid  = $valid && $is_jal;
         $jalr_valid = $valid && $is_jalr;
         
         //Destination register update - ALU result or load result depending on instruction
         $rf_wr_en = (($rd != '0) && $rd_valid && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = $valid ? $rd[4:0] : >>2$rd[4:0];
         $rf_wr_data[31:0] = $valid ? $result[31:0] : >>2$ld_data[31:0];
         
      @4
         //Data memory access for load, store
         $dmem_addr[3:0]     =  $result[5:2];
         $dmem_wr_en         =  $valid && $is_s_instr;
         $dmem_wr_data[31:0] =  $src2_value[31:0];
         $dmem_rd_en         =  $valid_load;
         
      
         //Write back data read from load instruction to register
         $ld_data[31:0]      =  $dmem_rd_data[31:0];
         
      
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //Checks if sum of numbers from 1 to 9 is obtained in reg[17] and runs 10 cycles extra after this is met
   *passed = |cpu/xreg[17]>>10$value == (1+2+3+4+5+6+7+8+9);
   //Run for 200 cycles without any checks
   //*passed = *cyc_cnt > 200;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule

  ```

 ![Screenshot (251)](https://github.com/user-attachments/assets/832945f5-847b-4a04-adbe-a54be166139d)

 ![Screenshot 2024-08-22 132714](https://github.com/user-attachments/assets/bc40ea6f-560c-49b4-bf5d-5512f2ee14bc)

  </details>

</details>



***



<details>
  <summary>LAB 6:  TL-Verilog to Verilog Conversion and Waveform Verification with GTKWave and Markerchip</summary>

  In this lab, we will convert the TLV code from our previous lab into Verilog using Python's Sandpiper-SaaS library. Once the conversion is complete, we'll develop a Verilog testbench to compare the waveforms generated by the MakerChip platform with those produced by the Verilog code in gtkwave.

Here are the steps required to convert TLV code to Verilog:

### Installation of necessary tools
Run the following commands in Ubuntu

**1. Install required packages**
```
 $ sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io
 $ sudo chmod 666 /var/run/docker.sock
 $ cd ~
 $ pip3 install pyyaml click sandpiper-saas
```
alternative commands
```
 $ sudo apt install make python python3 python3-pip git iverilog gtkwave
 $ sudo apt-get install python3-venv
 $ python3 -m venv .venv
 $ source ~/.venv/bin/activate
 $ pip3 install pyyaml click sandpiper-saas
```

**2. Clone the repository**
```
 $ cd
 $ git clone https://github.com/manili/VSDBabySoC.git
```

**3. Conversion of TL-Verilog code into Standard Verilog Code**
- __[TL-Verilog Code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv.tlv)__
  Place the TL-Verilog code provided into the VSDBabySoC/src/module directory
```
 $ cd VSDBabySoC
 $ sandpiper-saas -i ./src/module/*.tlv -o likith_riscv.v --bestsv --noline -p verilog --outdir ./src/module/
```
![Screenshot from 2024-08-27 00-39-01](https://github.com/user-attachments/assets/ff870aea-bdbb-48ea-b108-a57936ce323d)


**4. Run the Verilog code using iverilog**
  - __[Converted verilog code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv.v)__
  - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv_tb.v)__
    Place the test bench provided into the VSDBabySoC/src/module directory
```
 $ make pre_synth_sim 
 $ iverilog -o output/likith_riscv.out src/module/likith_riscv_tb.v -I src/include -I src/module
```
 If you encounter the following error, use this command:
 ![Screenshot from 2024-08-27 00-39-50](https://github.com/user-attachments/assets/56ea2bc8-9543-4321-a07f-df2847aecee4)

```
 $ iverilog -o output/likith_riscv.out -g2005-sv src/module/likith_riscv_tb.v -I src/include -I src/module
```

**5. Viewing waveforms in gtkwave**
```
 $ cd output
 $ ./likith_riscv.out
 $ gtkwave likith_riscv.vcd
```
**GTKWave:**
![Screenshot from 2024-08-27 02-51-21](https://github.com/user-attachments/assets/4dd9e539-5b01-4dea-b3c4-89417677bdf7)

**Makerchip:**
![Screenshot 2024-08-22 132714](https://github.com/user-attachments/assets/03bef1df-f7fa-47b8-a61e-51d67abe599f)

We successfully converted TLV code to Verilog using the Sandpiper-SaaS library and verified it by comparing waveforms from the MakerChip platform with those from the Verilog testbench in GTKWave

</details>


***


<details>
  <summary>LAB 7:  BabySoc Pre-synthesis simulation using iverilog GTKwave</summary>

Converting a digital output from a CPU into an analog signal using a DAC (Digital-to-Analog Converter) and PLL (Phase-Locked Loop)

**1. Clone the repository**
```
 $ cd
 $ git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation
```

```
$ iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
$ ./pre_synth_sim.out
$ gtkwave pre_synth_sim.vcd
```



![Screenshot from 2024-09-01 20-29-55](https://github.com/user-attachments/assets/15ec732a-4d8b-4ba3-bee4-89fe1646a923)

#### PLL input and DAC Output
![Screenshot from 2024-09-01 20-28-29](https://github.com/user-attachments/assets/32aaca0f-8fac-47d8-af91-941817052c76)
![Screenshot from 2024-09-01 20-27-49](https://github.com/user-attachments/assets/10cce90c-48ff-4197-92d5-57e23ad9c4f8)

</details>





***





<details>
  <summary>LAB 8: Verilog RTL Design Techniques Utilizing SKY130 CMOS Technology</summary>

  <details>
    <summary>Day 0: Installation of Necessary Tools</summary>

  <details>
  <summary>Yosys</summary>

  ```
  git clone https://github.com/YosysHQ/yosys.git
  cd yosys-master 
  sudo apt install make 
  sudo apt-get install build-essential clang bison flex \libreadline-dev gawk tcl-dev libffi-dev git\
                  graphviz xdot pkg-config python3 libboost-system-dev\
                  libboost-python-dev libboost-filesystem-dev zlib1g-dev
  make 
  sudo make install
  ```
  ![Screenshot from 2024-10-21 22-12-50](https://github.com/user-attachments/assets/27a04214-1b02-4ea7-badb-f49ed93e2a97)
  </details>


  <details>
  <summary> iverilog </summary>
      
  ```
  sudo apt-get install iverilog
  ```
  ![Screenshot from 2024-10-21 22-35-40](https://github.com/user-attachments/assets/39891605-e818-4b24-b572-0f50aba3b67c)
  </details>

  <details>
  <summary> GTKWave </summary>
      
  ```
  sudo apt-get install gtkwave
  ```
  ![Screenshot from 2024-10-21 22-38-01](https://github.com/user-attachments/assets/2dfe40c5-521b-4b74-97ad-29da3ae00412)
  </details>

  </details>


  <details>
    <summary>Day 1: Introduction to Verilog RTL Design and Synthesis</summary>

### RTL Design
RTL (Register Transfer Level) design is the process of translating specifications into a functional representation of a digital circuit. It serves as an intermediary between high-level behavioral design and low-level gate-level design. RTL focuses on the data transfer between registers, abstracting away the specifics of gate and transistor implementations. Typically, RTL designs are described using Hardware Description Languages (HDLs) such as Verilog or VHDL.

### Test Bench
A test bench is used to provide stimuli to the design under test (DUT) and verify its functionality as specified in the Verilog description. It is written separately and includes the instantiation of the design that needs to be simulated. The test bench facilitates the validation of the design's performance and behavior.

![Screenshot from 2024-10-21 23-18-04](https://github.com/user-attachments/assets/a9ef82dd-2f23-4cb2-966a-ebcdd9dc34fe)

## Introduction to iverilog and GTKWave

### IVERILOG
iverilog is an open-source tool for simulating and synthesizing Verilog designs. It is widely used for the design and verification of digital circuits described in the Verilog hardware description language (HDL).

### GTKWave
GTKWave is a widely-used open-source waveform viewer that enables users to visualize and analyze digital signal waveforms generated during circuit simulations. It is often paired with simulation tools like iverilog, providing a graphical representation of signal changes over time within a digital design.
  
![Screenshot from 2024-10-20 16-30-51](https://github.com/user-attachments/assets/ffec0429-8895-459c-9146-ce5482fa561f)

Lets simulate Mux using iverilog and GTKWave

- __[Mux verilog code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/good_mux.v)__
- __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_good_mux.v)__
      
  ```
  cd asic
  mkdir day1
  cd day1
  git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
  cd sky130RTLDesignAndSynthesisWorkshop
  cd verilog_files

  iverilog good_mux.v tb_good_mux.v
  ./a.out
  gtkwave tb_good_mux.vcd
  ```
![Screenshot from 2024-10-20 16-11-01](https://github.com/user-attachments/assets/d1f1f98b-cae3-4310-a781-9dadb95fcce2)
![Screenshot from 2024-10-20 16-11-12](https://github.com/user-attachments/assets/4d820473-d71a-4768-b964-9e82e8370cd6)
![Screenshot from 2024-10-20 23-48-02](https://github.com/user-attachments/assets/2053d4a8-7bf8-40a4-ad73-8ea6ccb406e7)

## Introduction Yosys
### Synthesis
Synthesis refers to the process of converting an RTL design, written in Verilog or another HDL, into a netlist that outlines the interconnections between components. This netlist is intended to perform the same function as the original HDL code. A synthesizer is the tool that facilitates this conversion, with Yosys being one such example.

### Yosys
Yosys is a tool designed to transform high-level hardware descriptions into optimized gate-level representations suitable for various FPGA and ASIC technologies. The typical workflow involves providing Yosys with the RTL design and a .lib file containing standard library cells. Yosys then synthesizes this information to produce a netlist file.

**Flow of Yosys Synthesis:**
![Screenshot from 2024-10-22 00-17-52](https://github.com/user-attachments/assets/b877e5b4-d29f-4504-b2ae-6adc5fd5a909)


![Screenshot from 2024-10-20 20-01-46](https://github.com/user-attachments/assets/a60ddc37-0141-4008-a933-6db4714472ea)

**Commands to Synthesize a design using Yosys:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog good_mux.v
synth -top good_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show 
write_verilog -noattr good_mux_netlist.v
!gedit good_mux_netlist.v 
  ```
![Screenshot from 2024-10-20 20-19-56](https://github.com/user-attachments/assets/8af64f7c-2811-4e81-88eb-e25cc8f36b2f)

**Synthesized Mux circuit:**
![Screenshot from 2024-10-20 20-20-07](https://github.com/user-attachments/assets/91d3f703-63b8-45e2-b692-b73e08d8d106)


![Screenshot from 2024-10-20 20-26-00](https://github.com/user-attachments/assets/26c36673-55c1-4202-9dcd-50f6b89e3e98)

**Synthesized Mux Netlist:**
- __[Mux Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/good_mux_netlist.v)__
![Screenshot from 2024-10-20 23-19-03](https://github.com/user-attachments/assets/d672aa35-e1c8-4598-a503-2ada759a0c9b)


  </details>


  <details>
    <summary>Day 2: Timing libs, Hierarchial vs Flat Synthesis and efficient flop coding styles</summary>
    
## Hierarchical synthesis and flat synthesis

 - __[Multiple Modules](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/multiple_modules.v)__
  
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_modules.v
synth -top multiple_modules
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show multiple_modules
write_verilog -noattr multiple_modules_hier.v
!gedit multiple_modules_hier.v 
  ```

  ```
module sub_module2 (input a, input b, output y);
	assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
	assign y = a&b;
endmodule

module multiple_modules (input a, input b, input c , output y);
	wire net1;
	sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
	sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule
  ```

![20241021_202206068_iOS](https://github.com/user-attachments/assets/4db6366d-1437-4c3d-b104-8408b64484bf)

Yosys synthesizer generates the following schematic instead of the above one
![Screenshot from 2024-10-21 02-34-52](https://github.com/user-attachments/assets/b23e24fa-740a-45f8-88bf-c40003df1f88)

**Hierarchial synthesis:** In the hierarchial synthesis the hierarchies are preserved. We can see the sub_module1(u1) and sub_module2 (u2) as above. The hierarchial netlist code is given below.
- __[Hierarchial synthesis](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/multiple_modules_hier.v)__
![Screenshot from 2024-10-22 01-27-46](https://github.com/user-attachments/assets/7800db08-14e6-4df6-81c1-e5e8ddcf1f73)

**Flattened netlist:** In flattened netlist, the hierarcies are flattend out and there is single module i.e, gates are instantiated directly instead of sub_modules.
**Commands to flatten the given design:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_modules.v
synth -top multiple_modules
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
flatten
show
write_verilog -noattr multiple_modules_hier.v
!gedit multiple_modules_hier.v 
  ```
**Flattend Design and Netlist:**
![Screenshot from 2024-10-21 02-52-30](https://github.com/user-attachments/assets/6b473428-71a5-4fc3-9a65-07f2a1361357)
- __[Flettened Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/multiple_modules_hier%20(flattend).v)__
![Screenshot from 2024-10-22 01-36-42](https://github.com/user-attachments/assets/2cc4a018-4161-4a31-96b9-8f724d247f18)


**Why Is Submodule Level Synthesis Important?**
- Submodule level synthesis is advantageous when dealing with multiple instances of the same module. Instead of synthesizing the same module repeatedly, we can synthesize it once and then replicate the resulting netlist as needed, effectively assembling it into the top module's netlist.
- This approach also embodies a "divide and conquer" strategy. For large designs, synthesis tools may struggle to optimize effectively. By breaking the design into smaller parts and synthesizing them individually, we can achieve optimized netlists for each section, which can then be combined to form the complete top module netlist.
  

**Commands to Submodule Level Synthesis:**
  
  ```
  cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
  yosys
  read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
  read_verilog multiple_modules.v
  synth -top sub_module1
  abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
  show
  ```

  ![Screenshot from 2024-10-21 02-59-06](https://github.com/user-attachments/assets/ff9ab546-96ab-49cd-ad7f-c75858393b45)

## Various Flop Coding Styles and Optimization

### Flop coding styles
- Asynchronous reset
- Asynchronous set
- Synchronous reset
- Synchronous set
- Both Asynchronous reset and Synchronous reset
- Both Asynchronous set and Synchronous set

### D Flipflop Asynchronous reset

**D Flipflop Asynchronous reset Simulation:**
 - __[Design](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/dff_asyncres.v)__
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_asyncres.v)__
  ```
 iverilog dff_asyncres.v tb_dff_asyncres.v
 ./a.out
 gtkwave tb_dff_asyncres.vcd
  ```
  ![Screenshot from 2024-10-21 03-23-51](https://github.com/user-attachments/assets/4c31c7d0-5fa9-485b-a82c-afe525abc95c)


**D Flipflop Asynchronous reset Synthesis:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_asyncres.v
synth -top dff_asyncres
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 03-40-34](https://github.com/user-attachments/assets/e9c12f99-9d74-4d4b-83d5-ce61e3c3215e)


### D Flipflop Asynchronous Set
**D Flipflop Asynchronous Set Simulation:**
 - __[Design](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/dff_async_set.v)__
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_async_set.v)__
  ```
iverilog dff_async_set.v tb_dff_async_set.v 
./a.out
gtkwave tb_dff_async_set.vcd
  ```
 ![Screenshot from 2024-10-21 03-28-37](https://github.com/user-attachments/assets/75fc9004-6baf-4297-9539-6fe8ac43951b)


**D Flipflop Asynchronous Set Synthesis:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_async_set.v
synth -top dff_async_set
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 03-42-48](https://github.com/user-attachments/assets/2c1832b0-cf81-483d-8d4f-b8269aa68b95)



### D Flipflop Synchronous Reset
**D Flipflop Synchronous Reset Simulation:**
 - __[Design](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/dff_syncres.v)__
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_syncres.v)__
  ```
iverilog dff_syncres.v tb_dff_syncres.v
./a.out
gtkwave tb_dff_syncres.vcd
  ```
![Screenshot from 2024-10-21 03-32-22](https://github.com/user-attachments/assets/41684bc9-5f32-4ce7-a190-f04304e7f026)



**D Flipflop Synchronous Reset Synthesis:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_syncres.v
synth -top dff_syncres
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 03-44-47](https://github.com/user-attachments/assets/840ad2e9-7093-46eb-8ac8-18e9fec3d726)


## Optimization

When we perform synthesis yosys optimise the circuit based on the logic.
### Example1:
  ```
module mul2 (input [2:0] a, output [3:0] y);
assign y = a * 2;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog mult_2.v
synth -top mul2
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr mult2_net.v
!gedit mult2_net.v
  ```
 
 - __[Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/mult2_net.v)__
![Screenshot from 2024-10-22 02-45-48](https://github.com/user-attachments/assets/bf811bbe-e248-4653-b26f-bc3437a52357)

### Example2:
  ```
module mult8 (input [2:0] a , output [5:0] y);
assign y = a * 9;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog mult_8.v
synth -top mult8
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr mult8_net.v
!gedit mult8_net.v
  ```
 
 - __[Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/mult8_net.v)__
![Screenshot from 2024-10-22 02-55-04](https://github.com/user-attachments/assets/c055e177-e620-4807-9099-0879927411e7)

  </details>



  <details>
    <summary>Day 3: Combinational and Sequential Optimization</summary>

## Combinational Logic Optimization
- Squeezing the logic to get the most optimised design
  - Area and Power savings
- Constant Propagation
   - Direct Optimisaton
- Boolean Logic Optimisation
  - K-Map
  - Quine McKluskey

    ![20241021_224028450_iOS](https://github.com/user-attachments/assets/f359cb2e-8712-4d00-b69b-ebc8fefc97a0)
    ![20241021_224100665_iOS](https://github.com/user-attachments/assets/ca73b9a0-9975-4df2-a24d-c3a790166423)

`opt_clean -purge` is used to optimize the synthesized design.   


### Example1
 ```
module opt_check (input a , input b , output y);
assign y = a?b:0;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check.v
synth -top opt_check
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```

**output is optimized to y = ab**

![Screenshot from 2024-10-21 05-47-26](https://github.com/user-attachments/assets/be30e22b-028c-4545-b26a-e905836ef7d0)




### Example2
 ```
module opt_check2 (input a , input b , output y);
assign y = a?1:b;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check2.v
synth -top opt_check2
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```

**output is optimized to y = a + b**

![Screenshot from 2024-10-21 05-49-17](https://github.com/user-attachments/assets/3c723069-98f0-4396-afe7-2839763c5cb8)


### Example3
 ```
module opt_check3 (input a , input b, input c , output y);
assign y = a?(c?b:0):0;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check3.v
synth -top opt_check3
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```

**output is optimized to y = abc**

![Screenshot from 2024-10-21 05-52-32](https://github.com/user-attachments/assets/20457ed2-7d46-4599-b1ea-83447d3f1986)


### Example4
 ```
module opt_check4 (input a , input b , input c , output y);
assign y = a?(b?(a & c ):c):(!c);
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check4.v
synth -top opt_check4
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
**output is optimized to y = xnor(a,c)**

![Screenshot from 2024-10-21 05-54-38](https://github.com/user-attachments/assets/fc021574-5ddd-45f2-a7df-ff8faf40ac66)

If there are multiple modules in the design -> First flatten then Optimize

### Example5
 ```
module sub_module1(input a , input b , output y);
assign y = a & b;
endmodule

module sub_module2(input a , input b , output y);
assign y = a^b;
endmodule

module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;
sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));
assign y = c | (b & n1); 
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_module_opt.v
synth -top multiple_module_opt
show multiple_module_opt
write_verilog -noattr multiple_module_opt_hier.v
flatten
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
**Before and After Optimization:**

![Screenshot from 2024-10-22 04-39-38](https://github.com/user-attachments/assets/cdb83320-c7c7-4940-bf77-5719dccfab22)

### Example6
 ```
module sub_module(input a , input b , output y);
assign y = a & b;
endmodule

module multiple_module_opt2(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
sub_module U2 (.a(b), .b(c) , .y(n2));
sub_module U3 (.a(n2), .b(d) , .y(n3));
sub_module U4 (.a(n3), .b(n1) , .y(y));
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_module_opt2.v
synth -top multiple_module_opt2
show multiple_module_opt2
write_verilog -noattr multiple_module_opt2_hier.v
flatten
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
**Before and After Optimization:**

![Screenshot from 2024-10-22 04-43-03](https://github.com/user-attachments/assets/97bd6f70-948b-458e-98c6-e2b9dece2e61)


## Sequential Logic Optimization
- Basic
   - Sequential Constant propagation
- Advanced [Not covered as part of Lab]
  - State optimisation
  - Retiming
  - Sequential Logic Cloning (Floor Plan Aware Synthesis)

### Example1
**Design**
 ```
module dff_const1(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const1.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const1.v tb_dff_const1.v
./a.out
gtkwave tb_dff_const1.vcd
  ```
![Screenshot from 2024-10-21 07-20-01](https://github.com/user-attachments/assets/51cfc7c0-6b4c-4172-ac1e-6cd0cd190758)

**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const1.v
synth -top dff_const1
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 06-54-21](https://github.com/user-attachments/assets/23476912-e7c7-4c39-9b61-0a0b283936a9)

### Example2
**Design**
 ```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const2.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const2.v tb_dff_const2.v
./a.out
gtkwave tb_dff_const2.vcd
  ```
![Screenshot from 2024-10-21 06-49-38](https://github.com/user-attachments/assets/aac19038-7765-4d2b-87d7-8ef4ec5e2333)


**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const2.v
synth -top dff_const2
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 06-56-35](https://github.com/user-attachments/assets/3945e225-4f1e-4f54-83b0-fb796f4bdb56)



### Example3
**Design**
 ```
module dff_const3(input clk, input reset, output reg q);
reg q1;
always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const3.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const3.v tb_dff_const3.v
./a.out
gtkwave tb_dff_const3.vcd
  ```
![Screenshot from 2024-10-21 07-09-33](https://github.com/user-attachments/assets/2bf8f6e0-a9a7-4e57-9bd6-cd98e76ddd7b)



**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const3.v
synth -top dff_const3
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 07-10-34](https://github.com/user-attachments/assets/77d584cd-3edc-4be7-b5bc-a3926218bc23)



### Example4
**Design**
 ```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const4.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const4.v tb_dff_const4.v
./a.out
gtkwave tb_dff_const4.vcd
  ```
![Screenshot from 2024-10-21 07-14-20](https://github.com/user-attachments/assets/8ffde49d-905e-4072-af9e-db41718aa579)



**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const4.v
synth -top dff_const4
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 07-15-05](https://github.com/user-attachments/assets/71471e46-0674-46fc-bde8-087e532743d8)



### Example5
**Design**
 ```
module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const5.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const5.v tb_dff_const5.v
./a.out
gtkwave tb_dff_const5.vcd
  ```
![Screenshot from 2024-10-21 07-16-25](https://github.com/user-attachments/assets/4e4c5cfa-728d-47c3-b541-5de43e6d4efa)




**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const5.v
synth -top dff_const5
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 07-16-37](https://github.com/user-attachments/assets/686dc833-6a01-4567-960b-2361d2df6fc1)


  </details>


  <details>
    <summary>Day 4: GLS, Blocking vs Non-Blocking and Synthesis-Simulation mismatch</summary>

  

  </details>


  

</details>






