<details>
  <summary>LAB 1:  Writing a C program and comparing the outputs when compiling the code with both GCC and the RISC-V compiler</summary>
   

   **Let's write a simple C program to count numbers from 1 to N and compile it using GCC.**

Code to count numbers from 1 to 30:

![Screenshot 2024-07-17 134436](https://github.com/user-attachments/assets/a684f778-bf97-4889-a4ff-e30908945d56)

Output:

![Screenshot from 2024-07-17 14-54-39](https://github.com/user-attachments/assets/918f5dba-6b4c-448f-9fb3-0d8d7de4a4da)

**Now let's compile the same code using RISC-V**

![Screenshot from 2024-07-17 14-54-45](https://github.com/user-attachments/assets/63a713bf-d308-4f0a-aa7b-80d3b56fb300)

![Screenshot from 2024-07-17 14-54-55](https://github.com/user-attachments/assets/8f09fa57-9167-4c6c-8f94-49de255c374a)

</details>



***



<details>
  <summary>LAB 2: Running the object file generated by the RISC-V compiler in the Spike Simulator, and performing debugging with the Spike Debugger</summary>
     
  In our previous lab, we compiled our C code using both gcc and a RISC-V compiler.
   
  ![Screenshot from 2024-07-20 14-17-33](https://github.com/user-attachments/assets/290c7134-0096-4802-84de-a00084905d32)

![Screenshot from 2024-07-20 14-20-11](https://github.com/user-attachments/assets/216bf957-e569-47a0-b448-0eeafaa4ba14)


Now, we will examine the output file generated by compiling the C code with the RISC-V compiler and debug the instructions.

Steps followed
1) Inspect the output generated by compiling the code with the gcc compiler, located in the file 'a.out'
2) Inspect the output generated by compiling the code with the RISC-V compiler, located in the file 'sum1toN.o'. and Check whether the outputs are the same or not
   
   ![Screenshot from 2024-07-20 14-18-57](https://github.com/user-attachments/assets/b971e17f-7aa8-4c52-9c0b-a1433c3e24a8)
   
4) Now we start debugging using the spike debugger
5) We will allow the Spike debugger to run until the main function, specifically until the **100b0** instruction. After that, we will manually continue debugging and inspect the **a0** register before and after the execution. We observe that the instruction **lui a0, 0x21** updates the a0 register from **0x0000000000000001** to **0x0000000000021000**
   
   ![Screenshot from 2024-07-20 15-10-29](https://github.com/user-attachments/assets/6928d9f4-c50e-4c29-a4df-28be34fb50b2)

6) Next, we will manually debug the next instruction  i.e., **addi sp, sp, -16**. This instruction decrements the stack pointer (sp) by 16. Before executing this instruction, the sp register held the value **0x0000003ffffffb50**, which is then updated to **0x0000003ffffffb40**

      ![Screenshot 2024-07-20 235518](https://github.com/user-attachments/assets/5efd476a-c03c-46d7-a20d-bd528eabd4f8)


The output appears at register 100b8, and it remains the same regardless of whether the code is executed using the gcc or riscv compilers.
   
</details>



***



<details>
  <summary>LAB 3: RISC-V instruction formats and their 32-bit encoded representations</summary>

  ## Base Instruction Formats

  RISC-V has six core instruction formats: R, I, S, B, U, and J. These are all fixed 32 bits in length. Here is a brief description of each format:

  There are four core instruction formats (R/I/S/U), and there are a further two variants of the instruction formats (B/J) based on the handling of immediates.
  1. **R-Type (Register)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | funct7[31:25]
     + Used for register-register arithmetic and logical operations.
       ![Screenshot 2024-07-24 191623](https://github.com/user-attachments/assets/0bbb9695-b331-46e2-a75a-92a074344659)

  2. **I-Type (Immediate)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | imm[31:20]
     + Used for immediate arithmetic, logical operations, and load instructions.
       ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)

  3. **S-Type (Store)**
     + Format: opcode[6:0] | imm[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for store instructions.
       ![Screenshot 2024-07-24 191625](https://github.com/user-attachments/assets/446beff5-399d-4426-b868-0d9c6d2ef271)

  4. **U-Type (Upper Immediate)**
     + Format: opcode[6:0] | rd[11:7] | imm[31:12]
     + Used for instructions that operate with a 20-bit upper immediate, such as LUI (Load Upper Immediate).
        ![Screenshot 2024-07-24 191626](https://github.com/user-attachments/assets/60c0073d-2e33-4fbd-a54b-01a606aeb353)

  5. **B-Type (Branch)**
     + Format: opcode[6:0] | imm[11][7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for conditional branch instructions.
       ![Screenshot 2024-07-24 191847](https://github.com/user-attachments/assets/33c0c62f-3fe2-48bd-a1f5-18db951807cf)

  6. **J-Type (Jump)**
     + Format: opcode[6:0] | rd[11:7] | imm[19:12] | imm[31:20]
     + Used for jump instructions, such as JAL (Jump And Link).
       ![Screenshot 2024-07-24 191848](https://github.com/user-attachments/assets/7b2e93a1-1fc8-447f-95ed-1d34b82e8625)
       
RISC-V instruction types and the corresponding 32-bit instruction codes for the provided instructions:

1. ADD r9, r10, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0000000
   + rs1: 01010
   + rs2: 01011
   + rd: 01001
   + Instruction: 0000000 01011 01010 000 01001 0110011
     + 0x00B504B3
     
2. SUB r11, r9, r10
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0100000
   + rs1: 01001
   + rs2: 01010
   + rd: 01011
   + Instruction: 0100000	01010	01001	000	01011	0110011
     + 0x40A485B3
     
3. AND r10, r9, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 111
   + funct7: 0000000
   + rs1: 01001
   + rs2: 01011
   + rd: 01010
   + Instruction: 0000000	01011	01001	111	01010	0110011
     + 0x00B4F533
       
4. OR r8, r10, r5
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 110
   + funct7: 0000000
   + rs1: 01010
   + rs2: 00101
   + rd: 01000
   + Instruction: 0000000	00101	01010	110	01000	0110011
     + 0x00556433
     
5. XOR r8, r9, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 100
   + funct7: 0000000
   + rs1: 01001
   + rs2: 00100
   + rd: 01000
   + Instruction: 0000000	00100	01001	100	01000	0110011
     + 0x0044C433
     
6. SLT r0, r1, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 010
   + funct7: 0000000
   + rs1: 00001
   + rs2: 00100
   + rd: 00000
   + Instruction: 0000000	00100	00001	010	00000	0110011
     + 0x0040A033
     
7. ADDI r2, r2, 5
   + Type: I-Type
   + Opcode: 0010011
   + funct3: 000
   + Immediate: 000000000101
   + rs1: 00010
   + rd: 00010
   + Instruction: 000000000101	00010	000	00010	0010011
     + 0x00510113
     
8. SW r2, r0, 4
   + Type: S-Type
   + Opcode: 0100011
   + funct3: 010
   + Immediate: 000000000100
   + imm[11:5]: 0000000
   + imm[4:0]: 00100
   + rs1: 00000
   + rd: 00010
   + Instruction: 0000000	00010	00000	010	00100	0100011
     + 0x00202223
     
9. SRL r6, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 101
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00110
    + Instruction: 0000000	00001	00001	101	00110	0110011
      + 0x0010D333
      
10. BNE r0, r0, 20
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 001
    + Immediate: 000000010100
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1010
    + Instruction: 0 000000	00000	00000	001	1010 0	1100011
      + 0x00001A63
      
11. BEQ r0, r0, 15
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 000
    + Immediate: 000000001111
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1111
    + Instruction: 0 000000	00000	00000	000	1111 0	1100011
      + 0x00000F63
      
12. LW r3, r1, 2
    + Type: I-Type
    + Opcode: 0000011
    + funct3: 010
    + Immediate: 000000000010
    + rs1: 00001
    + rd: 00011
    + Instruction: 000000000010	00001	010	00011	0000011
      + 0x0020A183
      
13. SLL r5, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 001
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00101
    + Instruction: 0000000	00001	00001	001	00101	0110011
      + 0x001092B3
   
  | Instruction | Format |  Standard ISA Code |
  | ----------- | ------ | ------------------ |
  | ADD r9, r10, r11 | R | 0x00B504B3 |
  | SUB r11, r9, r10 | R | 0x40A485B3 |
  | AND r10, r9, r11 | R | 0x00B4F533 |
  | OR r8, r10, r5 | R | 0x00556433 |
  | XOR r8, r9, r4 | R | 0x0044C433 |
  | SLT r0, r1, r4 | R | 0x0040A033 |
  | ADDI r2, r2, 5 | I | 0x00510113 |
  | SW r2, r0, 4 | S | 0x00202223 |
  | SRL r6, r1, r1 | R | 0x0010D333 |
  | BNE r0, r0, 20 | B | 0x00001A63 |
  | BEQ r0, r0, 15 | B | 0x00000F63 |
  | LW r3, r1, 2 | I | 0x0020A183 |
  | SLL r5, r1, r1 | R | 0x001092B3 |
  
  
  


</details>
  






