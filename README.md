<details>
  <summary>LAB 1:  Writing a C program and comparing the outputs when compiling the code with both GCC and the RISC-V compiler</summary>
   

   **Let's write a simple C program to count numbers from 1 to N and compile it using GCC.**

Code to count numbers from 1 to 30:

![Screenshot 2024-07-17 134436](https://github.com/user-attachments/assets/a684f778-bf97-4889-a4ff-e30908945d56)

Output:

![Screenshot from 2024-07-17 14-54-39](https://github.com/user-attachments/assets/918f5dba-6b4c-448f-9fb3-0d8d7de4a4da)

**Now let's compile the same code using RISC-V**

![Screenshot from 2024-07-17 14-54-45](https://github.com/user-attachments/assets/63a713bf-d308-4f0a-aa7b-80d3b56fb300)

We open the object dumpfile using the command
```
riscv64-unknown-elf-objdump -d -sum1toN.o | less
```

![Screenshot from 2024-07-17 14-54-55](https://github.com/user-attachments/assets/8f09fa57-9167-4c6c-8f94-49de255c374a)

</details>



***



<details>
  <summary>LAB 2: Running the object file generated by the RISC-V compiler in the Spike Simulator, and performing debugging with the Spike Debugger</summary>
     
  In our previous lab, we compiled our C code using both gcc and a RISC-V compiler.
   
  ![Screenshot from 2024-07-20 14-17-33](https://github.com/user-attachments/assets/290c7134-0096-4802-84de-a00084905d32)

![Screenshot from 2024-07-20 14-20-11](https://github.com/user-attachments/assets/216bf957-e569-47a0-b448-0eeafaa4ba14)


Now, we will examine the output file generated by compiling the C code with the RISC-V compiler and debug the instructions.

Steps followed
1) Inspect the output generated by compiling the code with the gcc compiler, located in the file 'a.out'
2) Inspect the output generated by compiling the code with the RISC-V compiler, located in the file 'sum1toN.o'. and Check whether the outputs are the same or not
   
   ![Screenshot from 2024-07-20 14-18-57](https://github.com/user-attachments/assets/b971e17f-7aa8-4c52-9c0b-a1433c3e24a8)
   
4) Now we start debugging using the spike debugger
5) We will allow the Spike debugger to run until the main function, specifically until the **100b0** instruction. After that, we will manually continue debugging and inspect the **a0** register before and after the execution. We observe that the instruction **lui a0, 0x21** updates the a0 register from **0x0000000000000001** to **0x0000000000021000**
   
   ![Screenshot from 2024-07-20 15-10-29](https://github.com/user-attachments/assets/6928d9f4-c50e-4c29-a4df-28be34fb50b2)

6) Next, we will manually debug the next instruction  i.e., **addi sp, sp, -16**. This instruction decrements the stack pointer (sp) by 16. Before executing this instruction, the sp register held the value **0x0000003ffffffb50**, which is then updated to **0x0000003ffffffb40**

      ![Screenshot 2024-07-20 235518](https://github.com/user-attachments/assets/5efd476a-c03c-46d7-a20d-bd528eabd4f8)

The output appears at register 100b8, and it remains the same regardless of whether the code is executed using the gcc or riscv compilers.

### Now we will see the difference in the switches O1 and Ofast
![Screenshot from 2024-08-12 21-08-32](https://github.com/user-attachments/assets/4da34596-2b81-47bd-8cec-640ced76a240)

**assembly code with O1 switch:**
![Screenshot from 2024-08-12 21-04-25](https://github.com/user-attachments/assets/184e2ba2-683e-4e9e-8855-6d6dcbedf306)

**assembly code with Ofast switch:**
![Screenshot from 2024-08-12 21-06-22](https://github.com/user-attachments/assets/48583f24-095d-42f7-bee7-64d438ede310)

+ Number of instructions when compiled with O1 switch = 14
+ Number of instructions when compiled with Ofast switch = 11
+ We can observe that using the **-Ofast** optimization switch results in fewer assembly instructions compared to the **-O1** switch.

</details>



***



<details>
  <summary>LAB 3: 32-bit RISC-V Instruction Formats: Encoding, Simulation, and Waveform Analysis </summary>

  ## Task 1: RISC-V Instruction Formats and Hexadecimal Encoding of Specific Instructions
  ### Base Instruction Formats

  RISC-V has six core instruction formats: R, I, S, B, U, and J. These are all fixed 32 bits in length. Here is a brief description of each format:

  There are four core instruction formats (R/I/S/U), and there are a further two variants of the instruction formats (B/J) based on the handling of immediates.
  1. **R-Type (Register)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | funct7[31:25]
     + Used for register-register arithmetic and logical operations.
       ![Screenshot 2024-07-24 191623](https://github.com/user-attachments/assets/0bbb9695-b331-46e2-a75a-92a074344659)

  2. **I-Type (Immediate)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | imm[31:20]
     + Used for immediate arithmetic, logical operations, and load instructions.
       ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)

  3. **S-Type (Store)**
     + Format: opcode[6:0] | imm[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for store instructions.
       ![Screenshot 2024-07-24 191625](https://github.com/user-attachments/assets/446beff5-399d-4426-b868-0d9c6d2ef271)

  4. **U-Type (Upper Immediate)**
     + Format: opcode[6:0] | rd[11:7] | imm[31:12]
     + Used for instructions that operate with a 20-bit upper immediate, such as LUI (Load Upper Immediate).
        ![Screenshot 2024-07-24 191626](https://github.com/user-attachments/assets/60c0073d-2e33-4fbd-a54b-01a606aeb353)

  5. **B-Type (Branch)**
     + Format: opcode[6:0] | imm[11][7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for conditional branch instructions.
       ![Screenshot 2024-07-24 191847](https://github.com/user-attachments/assets/33c0c62f-3fe2-48bd-a1f5-18db951807cf)

  6. **J-Type (Jump)**
     + Format: opcode[6:0] | rd[11:7] | imm[19:12] | imm[31:20]
     + Used for jump instructions, such as JAL (Jump And Link).
       ![Screenshot 2024-07-24 191848](https://github.com/user-attachments/assets/7b2e93a1-1fc8-447f-95ed-1d34b82e8625)
       
RISC-V instruction types and the corresponding 32-bit instruction codes for the provided instructions:

1. ADD r9, r10, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0000000
   + rs1: 01010
   + rs2: 01011
   + rd: 01001
   + Instruction: 0000000 01011 01010 000 01001 0110011
     + 0x00B504B3
     
2. SUB r11, r9, r10
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0100000
   + rs1: 01001
   + rs2: 01010
   + rd: 01011
   + Instruction: 0100000	01010	01001	000	01011	0110011
     + 0x40A485B3
     
3. AND r10, r9, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 111
   + funct7: 0000000
   + rs1: 01001
   + rs2: 01011
   + rd: 01010
   + Instruction: 0000000	01011	01001	111	01010	0110011
     + 0x00B4F533
       
4. OR r8, r10, r5
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 110
   + funct7: 0000000
   + rs1: 01010
   + rs2: 00101
   + rd: 01000
   + Instruction: 0000000	00101	01010	110	01000	0110011
     + 0x00556433
     
5. XOR r8, r9, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 100
   + funct7: 0000000
   + rs1: 01001
   + rs2: 00100
   + rd: 01000
   + Instruction: 0000000	00100	01001	100	01000	0110011
     + 0x0044C433
     
6. SLT r0, r1, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 010
   + funct7: 0000000
   + rs1: 00001
   + rs2: 00100
   + rd: 00000
   + Instruction: 0000000	00100	00001	010	00000	0110011
     + 0x0040A033
     
7. ADDI r2, r2, 5
   + Type: I-Type
   + Opcode: 0010011
   + funct3: 000
   + Immediate: 000000000101
   + rs1: 00010
   + rd: 00010
   + Instruction: 000000000101	00010	000	00010	0010011
     + 0x00510113
     
8. SW r2, r0, 4
   + Type: S-Type
   + Opcode: 0100011
   + funct3: 010
   + Immediate: 000000000100
   + imm[11:5]: 0000000
   + imm[4:0]: 00100
   + rs1: 00000
   + rd: 00010
   + Instruction: 0000000	00010	00000	010	00100	0100011
     + 0x00202223
     
9. SRL r6, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 101
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00110
    + Instruction: 0000000	00001	00001	101	00110	0110011
      + 0x0010D333
      
10. BNE r0, r0, 20
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 001
    + Immediate: 000000010100
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1010
    + Instruction: 0 000000	00000	00000	001	1010 0	1100011
      + 0x00001A63
      
11. BEQ r0, r0, 15
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 000
    + Immediate: 000000001111
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1111
    + Instruction: 0 000000	00000	00000	000	1111 0	1100011
      + 0x00000F63
      
12. LW r3, r1, 2
    + Type: I-Type
    + Opcode: 0000011
    + funct3: 010
    + Immediate: 000000000010
    + rs1: 00001
    + rd: 00011
    + Instruction: 000000000010	00001	010	00011	0000011
      + 0x0020A183
      
13. SLL r5, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 001
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00101
    + Instruction: 0000000	00001	00001	001	00101	0110011
      + 0x001092B3
   
    | Instruction | Format |  Standard ISA Code |
    | :----------: | :------: | :------------------: |
    | ADD r9, r10, r11 | R | 0x00B504B3 |
    | SUB r11, r9, r10 | R | 0x40A485B3 |
    | AND r10, r9, r11 | R | 0x00B4F533 |
    | OR r8, r10, r5 | R | 0x00556433 |
    | XOR r8, r9, r4 | R | 0x0044C433 |
    | SLT r0, r1, r4 | R | 0x0040A033 |
    | ADDI r2, r2, 5 | I | 0x00510113 |
    | SW r2, r0, 4 | S | 0x00202223 |
    | SRL r6, r1, r1 | R | 0x0010D333 |
    | BNE r0, r0, 20 | B | 0x00001A63 |
    | BEQ r0, r0, 15 | B | 0x00000F63 |
    | LW r3, r1, 2 | I | 0x0020A183 |
    | SLL r5, r1, r1 | R | 0x001092B3 |

  ## Task 2: Simulation and Waveform analysis
  ### Steps to perform functional simulational
  1. Create two files in gedit as iiitb_rv32i.v and iiitb_rv32i_tb.v
  2. Copy the code from the reference github repository and paste it in your verilog and testbench files
  3. To run and simulate the verilog code in gtkwave, enter the following commands:
     ![Screenshot from 2024-07-28 18-34-21](https://github.com/user-attachments/assets/16c1874b-3d22-4eb4-b84c-5790071a1bff)

  **Following are the differences between standard RISCV ISA and Hardcoded ISA for the instruction set given in the reference repository:**  

  The standard RISC-V ISA for the given instructions can be generated in a manner similar to the approach we used in Task 1
  
  Hard-coded instructions: These are custom instructions where the bit patterns are manually set by the designer rather than adhering to the standard RISC-V specification. And they are designed for a specific purpose or application. Hence the 32-bits instruction that we generated will not match with the hardcoded ISA.
  
  
  |  **Instructions**  |  **Standard RISCV ISA**  |  **Hardcoded ISA**  |  
  |  :----:  |  :----:  |  :----:  |  
  |  ADD R6, R2, R1  |  32'h00110333  |  32'h02208300  |  
  |  SUB R7, R1, R2  |  32'h402083b3  |  32'h02209380  |  
  |  AND R8, R1, R3  |  32'h0030f433  |  32'h0230a400  |  
  |  OR R9, R2, R5  |  32'h005164b3  |  32'h02513480  |  
  |  XOR R10, R1, R4  |  32'h0040c533  |  32'h0240c500  |  
  |  SLT R1, R2, R4  |  32'h0045a0b3  |  32'h02415580  |  
  |  ADDI R12, R4, 5  |  32'h004120b3  |  32'h00520600  |  
  |  BEQ R0, R0, 15  |  32'h00000f63  |  32'h00f00002  |  
  |  SW R3, R1, 2  |  32'h0030a123  |  32'h00209181  |  
  |  LW R13, R1, 2  |  32'h0020a683  |  32'h00208681  |  
  |  SRL R16, R14, R2  |  32'h0030a123  |  32'h00271803  |
  |  SLL R15, R1, R2  |  32'h002097b3  |  32'h00208783  |  

  ### Analysing output waveforms of above given instructions:

  ```
  ADD R6, R2, R1
  ```
  ![IMG_0010](https://github.com/user-attachments/assets/30cb6411-4c2a-4a2b-9f43-430c505ac4e7)


  ```
  SUB R7, R1, R2
  ```
  ![IMG_0013](https://github.com/user-attachments/assets/aa230620-2c97-4abb-b0a3-96fd3995f3a8)

  
  ```
  AND R8, R1, R3
  ```
  ![IMG_0027](https://github.com/user-attachments/assets/cad8c2be-643e-431e-8579-460a29b6a59c)


  ```
  OR R9, R2, R5
  ```
  ![IMG_0016](https://github.com/user-attachments/assets/88b1edde-9b3d-4271-af0c-dac55c3300dc)


  ```
  XOR R10, R1, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/95486b24-2a92-4d3b-8f18-4c549ee5bf4f)


  ```
  SLT R1, R2, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/13e32a3b-a2e3-4105-9df3-1cf0fe0c60a4)


  ```
  ADDI R12, R4, 5
  ```
  ![IMG_0009](https://github.com/user-attachments/assets/8de296ea-9d55-4dba-9c89-738b470e5d97)


  ```
  BEQ R0, R0, 15
  ```
  ![IMG_0012](https://github.com/user-attachments/assets/a3c34a83-c1e6-4d80-bae5-f187535afc77)


 **5-Stage instruction pipeline**
 ![Screenshot from 2024-07-29 03-34-25](https://github.com/user-attachments/assets/f3e95dc9-f367-4cbb-ad81-0a73c286b899)

</details>


***



<details>
  <summary>LAB 4:  Selecting and Compiling a C Application with GCC and RISC-V GCC compiler</summary>
  
  ## Application Name: Logic Gate Simulator
  ### Overview: Simulates the behavior of basic logic gates (AND, OR, NOT, etc.) with truth tables and custom inputs
  **Logic Gate Simulator** is a C-based application designed to simulate the behavior of basic logic gates, including AND, OR, NOT, XOR, NAND, NOR. The application allows users to input custom values, generate truth tables

  **Code:**
  ```c
#include <stdio.h>

// Function prototypes for logic gates
int AND(int a, int b);
int OR(int a, int b);
int NOT(int a);
int XOR(int a, int b);
int NAND(int a, int b);
int NOR(int a, int b);

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name);

// Function to print the truth table for NOT gate
void print_truth_table_not();

// Main function
int main() {
    int choice;
    
    printf("Logic Gate Simulator\n");
    printf("1. AND Gate\n");
    printf("2. OR Gate\n");
    printf("3. NOT Gate\n");
    printf("4. XOR Gate\n");
    printf("5. NAND Gate\n");
    printf("6. NOR Gate\n");
    printf("Enter your choice (1-6): ");
    scanf("%d", &choice);

    switch(choice) {
        case 1:
            print_truth_table_two_inputs(AND, "AND");
            break;
        case 2:
            print_truth_table_two_inputs(OR, "OR");
            break;
        case 3:
            print_truth_table_not();
            break;
        case 4:
            print_truth_table_two_inputs(XOR, "XOR");
            break;
        case 5:
            print_truth_table_two_inputs(NAND, "NAND");
            break;
        case 6:
            print_truth_table_two_inputs(NOR, "NOR");
            break;
        default:
            printf("Invalid choice!\n");
    }

    return 0;
}

// AND gate function
int AND(int a, int b) {
    return a & b;
}

// OR gate function
int OR(int a, int b) {
    return a | b;
}

// NOT gate function
int NOT(int a) {
    return !a;
}

// XOR gate function
int XOR(int a, int b) {
    return a ^ b;
}

// NAND gate function
int NAND(int a, int b) {
    return !(a & b);
}

// NOR gate function
int NOR(int a, int b) {
    return !(a | b);
}

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name) {
    printf("\nTruth Table for %s Gate\n", gate_name);
    printf("A B | Output\n");
    printf("------------\n");

    for(int a = 0; a <= 1; a++) {
        for(int b = 0; b <= 1; b++) {
            printf("%d %d |   %d\n", a, b, gate(a, b));
        }
    }
}

// Function to print the truth table for NOT gate
void print_truth_table_not() {
    printf("\nTruth Table for NOT Gate\n");
    printf("A | Output\n");
    printf("---------\n");

    for(int a = 0; a <= 1; a++) {
        printf("%d |   %d\n", a, NOT(a));
    }
}
```

**Compiling the application using the GCC compiler:**

![Screenshot from 2024-08-14 20-17-59](https://github.com/user-attachments/assets/5aa3c864-798a-468e-a0ff-294b7c522f0b)


**Compiling the application using the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-18-56](https://github.com/user-attachments/assets/6264cabc-ee3d-4e84-8906-1fc4b3fb76a3)

**Comparing the output of the application when compiled with the standard GCC compiler versus the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-19-49](https://github.com/user-attachments/assets/31633f1a-5c3c-480a-97f6-85663384a5d2)


</details>


***


<details>
  <summary>LAB 5: 5 Stage Pipelined RISC-V Processor </summary>
  
**TL-Verilog** is a higher-level version of Verilog used for modeling and designing digital systems in a more abstract way. Instead of focusing on the detailed wiring and gates, TL-Verilog lets you describe how a system behaves without getting into the specifics of its implementation. This abstraction is useful for system-level design and simulation.

**Makerchip** is an online platform where you can design, simulate, and test digital systems using HDLs like TL-Verilog, Verilog, and VHDL. It offers a user-friendly environment for creating and experimenting with digital designs, making it great for learning, teaching, and prototyping. 
  
  <details>
    <summary> Digital Logic with TL-Verilog and Makerchip </summary>
Logic gates are essential parts of digital circuits. They perform basic operations on binary data (0s and 1s) and are key to how computers and other digital devices handle information. There are different types of logic gates, each with a specific function
    
  ![Screenshot (219)](https://github.com/user-attachments/assets/37dc2892-d103-4f6c-9e1c-d6bcde83cfd1)
  ![Screenshot (220)](https://github.com/user-attachments/assets/042668ea-4aea-4698-9850-4742b14bc3a1)
    
  ### Combinational Logic in TL-Verilog and Makerchip
  
  Combinational logic involves creating circuits that process binary inputs to produce binary outputs based on set rules. These circuits operate without memory or feedback, meaning their outputs depend only on the current inputs and not on past states.
  
  **1) Inverter on Makerchip**
     ![Screenshot (209)](https://github.com/user-attachments/assets/73a65273-f58c-47cb-b0cd-08f38ab66bcf)     
  **2) AND gate on Makerchip**
     ![Screenshot (210)](https://github.com/user-attachments/assets/2aef5ed9-377a-43ef-b8c6-f9525a4be4e6)
  **3) OR gate on Makerchip**
     ![Screenshot (212)](https://github.com/user-attachments/assets/afef06d7-b4cd-4ab9-a014-12672f220c2a)
  **4) EXOR gate on Makerchip**
     ![Screenshot (213)](https://github.com/user-attachments/assets/ce40afa4-ddec-4918-bfa8-67600cb20964)
  **5) Vectors on Makerchip**
     ![Screenshot (214)](https://github.com/user-attachments/assets/3c5081a4-eddd-4544-b6c7-3280bf8cd100)
  **6) Mux on Makerchip**
     ![Screenshot (215)](https://github.com/user-attachments/assets/3a3b02c7-be90-41f5-b290-6b03b845eb67)
     ![Screenshot (216)](https://github.com/user-attachments/assets/9b687af5-a899-4641-9be3-7d33632490c0)
  **7) Calculator on Makerchip**
  ```c
\TLV
   $reset = *reset;
   
   $val1[31:0] = $rand1[3:0];
   $val2[31:0] = $rand2[3:0];
   $sum[31:0]  = $val1[31:0] + $val2[31:0];
   $diff[31:0] = $val1[31:0] - $val2[31:0];
   $prod[31:0] = $val1[31:0] * $val2[31:0];
   $quot[31:0] = $val1[31:0] / $val2[31:0];
   
   $out[31:0] = $op[1] ? ($op[0] ? $quot[31:0] : $prod[31:0]) : ($op[0] ? $diff[31:0] : $add[31:0]); 
  ```

  ![Screenshot (218)](https://github.com/user-attachments/assets/d97dcefb-635b-4c5d-91b5-6338297be285)


  ### Sequential Logic in TL-Verilog and Makerchip
  Sequential logic is a type of digital circuit where the output depends on both the current inputs and the circuit's previous states. Unlike combinational logic, which only uses current inputs to produce outputs, sequential logic includes memory elements to keep track of past information and influence the current output.
  
**1) Sequential calculator on Makerchip**
![Screenshot (222)](https://github.com/user-attachments/assets/9d23930c-9b12-4529-8c0f-14c59fd0da43)


  ```c
\TLV
   |calc
      @1
         $clk_lik = *clk;
         $reset = *reset;
         $val1[31:0] = >>1$result[31:0];
         $val2[31:0] = $rand2[3:0];
         $result[31:0] = $reset ? 32'b0 : ($sel[1:0] == 2'b00)
                         ? ($val1[31:0] + $val2[31:0]) : ($sel[1:0] == 2'b01)
                         ? ($val1[31:0] - $val2[31:0]) : ($sel[1:0] == 2'b10)
                         ? ($val1[31:0] * $val2[31:0]) : ($sel[1:0] == 2'b11)
                         ? ($val2[31:0] != 0 ? ($val1[31:0] / $val2[31:0]) : 32'bx) :  32'b0;
 ```

  ![Screenshot (221)](https://github.com/user-attachments/assets/10f9e7de-4be1-4d33-9103-3adacdd45b3c)


  ### Pipelined Logic
  
Pipelining is a key feature in TL-Verilog that simplifies coding and helps reduce bugs compared to SystemVerilog. In TL-Verilog, you can easily implement pipelining with less code. For example, in the provided repo, you can see how pipelining is used to calculate the Pythagorean theorem. In TL-Verilog, you define the pipeline stages using |calc and align them with @1, @2, and so on.



**2-Cycle Calculator in Pipeline**

![Screenshot (226)](https://github.com/user-attachments/assets/d4c28f9f-d80b-4618-99fe-d1c3f7e7626e)


```c
\TLV
   |calc
      @1
         $reset = *reset;
         $clk_lik = *clk;
         $val1[31:0] = >>2$out[31:0];
         $val2[31:0] = $rand2[3:0];
         $op[1:0] = $rand3[1:0];
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         
         $num = $reset ? 0 : >>1$num+1;
      @2   
         $out[31:0] = ($reset|!$num) ? 32'b0 : (($op[1:0]==2'b00) ? $sum :
                                       ($op[1:0]==2'b01) ? $diff :
                                          ($op[1:0]==2'b10) ? $prod : $quot);
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
```
![Screenshot (227)](https://github.com/user-attachments/assets/4ba5d5df-4b1b-4767-aac9-d618c337afca)


  ### Validity
  **1) 2-Cycle Calculator with Validity**
  
  ![Screenshot (233)](https://github.com/user-attachments/assets/eb5d65f4-1688-4bba-b263-9a4078c43be6)

  ```c
\TLV
    |calc
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
      @1
         $val1 [31:0] = >>2$out;
         $val2 [31:0] = $rand2[3:0];
         
         $valid = $reset ? 1'b0 : >>1$valid + 1'b1 ;
         $valid_or_reset = $valid || $reset;
         
      ?$vaild_or_reset
         @1   
            $sum [31:0] = $val1 + $val2;
            $diff[31:0] = $val1 - $val2;
            $prod[31:0] = $val1 * $val2;
            $quot[31:0] = $val1 / $val2;
            
         @2   
            $mem[31:0] = $reset ? 32'b0 :
                         ($op[2:0] == 3'b101) ? $val1 : >>2$mem ;
            
            $out [31:0] = $reset ? 32'b0 :
                          ($op[2:0] == 3'b000) ? $sum :
                          ($op[2:0] == 3'b001) ? $diff :
                          ($op[2:0] == 3'b010) ? $prod :
                          ($op[2:0] == 3'b011) ? $quot :
                          ($op[2:0] == 3'b100) ? >>2$mem : >>2$out ;
  ```
![Screenshot (234)](https://github.com/user-attachments/assets/1b1824fc-60f2-42d6-99fb-ae8fc9a00eae)


  **2) Calculator with single value memory**
  
![Screenshot (236)](https://github.com/user-attachments/assets/4f59abf9-15e6-48b5-b579-4924577dfc63)
```c
\TLV
    |calc
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
      @1
         $val1 [31:0] = >>2$out;
         $val2 [31:0] = $rand2[3:0];
         
         $valid = $reset ? 1'b0 : >>1$valid + 1'b1 ;
         $valid_or_reset = $valid || $reset;
         
      ?$vaild_or_reset
         @1   
            $sum [31:0] = $val1 + $val2;
            $diff[31:0] = $val1 - $val2;
            $prod[31:0] = $val1 * $val2;
            $quot[31:0] = $val1 / $val2;
            
         @2   
            $mem[31:0] = $reset ? 32'b0 :
                         ($op[2:0] == 3'b101) ? $val1 : >>2$mem ;
            
            $out [31:0] = $reset ? 32'b0 :
                          ($op[2:0] == 3'b000) ? $sum :
                          ($op[2:0] == 3'b001) ? $diff :
                          ($op[2:0] == 3'b010) ? $prod :
                          ($op[2:0] == 3'b011) ? $quot :
                          ($op[2:0] == 3'b100) ? >>2$mem : >>2$out ;
```
![Screenshot (237)](https://github.com/user-attachments/assets/9195b7f4-1db3-4afe-ab27-482f80ef35f4)

  </details>

  
  <details>
    <summary> Basic RISC-V CPU micro-architecture </summary>
    
  ### Introduction to Simple RISC-V micro-architecture 
  RISC-V block diagram A block diagram of a RISC-V processor provides a high-level overview of its major components and how they are interconnected. Here's a block diagram of a typical RISC-V processor:

  + **Decoder:** The decoder translates binary instructions into control signals that direct the processor's functional units on how to execute them.
  + **Instruction Memory:** Instruction memory stores and supplies the machine instructions needed by the processor for execution.
  + **ALU (Arithmetic Logic Unit):** The ALU performs arithmetic and logical operations on data, such as addition and comparisons.
  + **ALU Control Unit:** The ALU control unit provides signals to configure the ALU for the specific operation required by the current instruction.
  + **Register File:** The register file contains general-purpose registers that temporarily store data during instruction execution.
  + **Data Memory:** Data memory holds data for read and write operations and is used in load and store instructions.

  ### Fetch and Decode
  
  

  ### RISC-V Control logic

  </details>


  <details>
    <summary> Complete Pipelined RISC-V CPU micro-architecture </summary>
    
  ### RISCV core with Pipeline
  ```c
\m4_TLV_version 1d: tl-x.org
\SV
   // Template code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 10000)           // Store r10 result in dmem
   m4_asm(LW, r17, r0, 10000)           // Load contents of dmem to r17
   m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
         //PC fetch - branch, jumps and loads introduce 2 cycle bubbles in this pipeline
         $pc[31:0] = >>1$reset ? '0 : (>>3$valid_taken_br ? >>3$br_tgt_pc :
                                       >>3$valid_load     ? >>3$inc_pc[31:0] :
                                       >>3$jal_valid      ? >>3$br_tgt_pc :
                                       >>3$jalr_valid     ? >>3$jalr_tgt_pc :
                                                     (>>1$inc_pc[31:0]));
         // Access instruction memory using PC
         $imem_rd_en = ~ $reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         
         
      @1
         //Getting instruction from IMem
         $instr[31:0] = $imem_rd_data[31:0];
         
         //Increment PC
         $inc_pc[31:0] = $pc[31:0] + 32'h4;
         
         //Decoding I,R,S,U,B,J type of instructions based on opcode [6:0]
         //Only [6:2] is used here because this implementation is for RV64I which does not use [1:0]
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $is_j_instr = $instr[6:2] == 5'b11011;
         
         //Immediate value decode
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}} , $instr[30:20]} :
                      $is_s_instr ? { {21{$instr[31]}} , $instr[30:25] , $instr[11:8] , $instr[7]} :
                      $is_b_instr ? { {20{$instr[31]}} , $instr[7] , $instr[30:25] , $instr[11:8] , 1'b0} :
                      $is_u_instr ? { $instr[31] , $instr[30:12] , { 12{1'b0}} } :
                      $is_j_instr ? { {12{$instr[31]}} , $instr[19:12] , $instr[20] , $instr[30:21] , 1'b0} :
                      >>1$imm[31:0];
         
         //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
         
         //Decode other fields of instruction - source and destination registers, funct, opcode
         ?$rs1_or_funct3_valid
            $rs1[4:0]    = $instr[19:15];
            $funct3[2:0] = $instr[14:12];
         
         ?$rs2_valid
            $rs2[4:0]    = $instr[24:20];
         
         ?$rd_valid
            $rd[4:0]     = $instr[11:7];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         //Decode instruction in subset of base instruction set based on RISC-V 32I
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         //Branch instructions
         $is_beq   = $dec_bits ==? 11'bx_000_1100011;
         $is_bne   = $dec_bits ==? 11'bx_001_1100011;
         $is_blt   = $dec_bits ==? 11'bx_100_1100011;
         $is_bge   = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu  = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu  = $dec_bits ==? 11'bx_111_1100011;
         
         //Jump instructions
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal   = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr  = $dec_bits ==? 11'bx_000_1100111;
         
         //Arithmetic instructions
         $is_addi  = $dec_bits ==? 11'bx_000_0010011;
         $is_add   = $dec_bits ==  11'b0_000_0110011;
         $is_lui   = $dec_bits ==? 11'bx_xxx_0110111;
         $is_slti  = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori  = $dec_bits ==? 11'bx_100_0010011;
         $is_ori   = $dec_bits ==? 11'bx_110_0010011;
         $is_andi  = $dec_bits ==? 11'bx_111_0010011;
         $is_slli  = $dec_bits ==? 11'b0_001_0010011;
         $is_srli  = $dec_bits ==? 11'b0_101_0010011;
         $is_srai  = $dec_bits ==? 11'b1_101_0010011;
         $is_sub   = $dec_bits ==? 11'b1_000_0110011;
         $is_sll   = $dec_bits ==? 11'b0_001_0110011;
         $is_slt   = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu  = $dec_bits ==? 11'b0_011_0110011;
         $is_xor   = $dec_bits ==? 11'b0_100_0110011;
         $is_srl   = $dec_bits ==? 11'b0_101_0110011;
         $is_sra   = $dec_bits ==? 11'b1_101_0110011;
         $is_or    = $dec_bits ==? 11'b0_110_0110011;
         $is_and   = $dec_bits ==? 11'b0_111_0110011;
         
         //Store instructions
         $is_sb    = $dec_bits ==? 11'bx_000_0100011;
         $is_sh    = $dec_bits ==? 11'bx_001_0100011;
         $is_sw    = $dec_bits ==? 11'bx_010_0100011;
         
         //Load instructions - support only 4 byte load
         $is_load  = $dec_bits ==? 11'bx_xxx_0000011;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         //Get Source register values from reg file
         $rf_rd_en1 = $rs1_or_funct3_valid;
         $rf_rd_en2 = $rs2_valid;
         
         $rf_rd_index1[4:0] = $rs1[4:0];
         $rf_rd_index2[4:0] = $rs2[4:0];
         
         //Register file bypass logic - data forwarding from ALU to resolve RAW dependence
         $src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
         $src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
         
         //Branch target PC computation for branches and JAL
         $br_tgt_pc[31:0] = $imm[31:0] + $pc[31:0];
         
         //RAW dependence check for ALU data forwarding
         //If previous instruction was writing to reg file, and current instruction is reading from same register
         $rs1_bypass = >>1$rf_wr_en && (>>1$rd == $rs1);
         $rs2_bypass = >>1$rf_wr_en && (>>1$rd == $rs2);
         
      @3
         //ALU
         $result[31:0] = $is_addi  ? $src1_value +  $imm :
                         $is_add   ? $src1_value +  $src2_value :
                         $is_andi  ? $src1_value &  $imm :
                         $is_ori   ? $src1_value |  $imm :
                         $is_xori  ? $src1_value ^  $imm :
                         $is_slli  ? $src1_value << $imm[5:0]:
                         $is_srli  ? $src1_value >> $imm[5:0]:
                         $is_and   ? $src1_value &  $src2_value:
                         $is_or    ? $src1_value |  $src2_value:
                         $is_xor   ? $src1_value ^  $src2_value:
                         $is_sub   ? $src1_value -  $src2_value:
                         $is_sll   ? $src1_value << $src2_value:
                         $is_srl   ? $src1_value >> $src2_value:
                         $is_sltu  ? $sltu_rslt[31:0]:
                         $is_sltiu ? $sltiu_rslt[31:0]:
                         $is_lui   ? {$imm[31:12], 12'b0}:
                         $is_auipc ? $pc + $imm:
                         $is_jal   ? $pc + 4:
                         $is_jalr  ? $pc + 4:
                         $is_srai  ? ({ {32{$src1_value[31]}} , $src1_value} >> $imm[4:0]) :
                         $is_slt   ? (($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]}):
                         $is_slti  ? (($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]}) :
                         $is_sra   ? ({ {32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $is_load  ? $src1_value +  $imm :
                         $is_s_instr ? $src1_value + $imm :
                                    32'bx;
         
         $sltu_rslt[31:0]  = $src1_value <  $src2_value;
         $sltiu_rslt[31:0] = $src1_value <  $imm;
         
         //Jump instruction target PC computation
         $jalr_tgt_pc[31:0] = $imm[31:0] + $src1_value[31:0]; 
         
         //Branch resolution
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
         $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid || >>1$jump_valid);
         
         //Current instruction is valid & is a taken branch
         $valid_taken_br = $valid && $taken_br;
         
         //Current instruction is valid & is a load
         $valid_load = $valid && $is_load;
         
         //Current instruction is valid & is jump
         $jump_valid = $valid && $is_jump;
         $jal_valid  = $valid && $is_jal;
         $jalr_valid = $valid && $is_jalr;
         
         //Destination register update - ALU result or load result depending on instruction
         $rf_wr_en = (($rd != '0) && $rd_valid && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = $valid ? $rd[4:0] : >>2$rd[4:0];
         $rf_wr_data[31:0] = $valid ? $result[31:0] : >>2$ld_data[31:0];
         
      @4
         //Data memory access for load, store
         $dmem_addr[3:0]     =  $result[5:2];
         $dmem_wr_en         =  $valid && $is_s_instr;
         $dmem_wr_data[31:0] =  $src2_value[31:0];
         $dmem_rd_en         =  $valid_load;
         
      
         //Write back data read from load instruction to register
         $ld_data[31:0]      =  $dmem_rd_data[31:0];
         
      
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //Checks if sum of numbers from 1 to 9 is obtained in reg[17] and runs 10 cycles extra after this is met
   *passed = |cpu/xreg[17]>>10$value == (1+2+3+4+5+6+7+8+9);
   //Run for 200 cycles without any checks
   //*passed = *cyc_cnt > 200;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule

  ```

 ![Screenshot (251)](https://github.com/user-attachments/assets/832945f5-847b-4a04-adbe-a54be166139d)

 ![Screenshot 2024-08-22 132714](https://github.com/user-attachments/assets/bc40ea6f-560c-49b4-bf5d-5512f2ee14bc)

  </details>

</details>



***



<details>
  <summary>LAB 6:  TL-Verilog to Verilog Conversion and Waveform Verification with GTKWave and Markerchip</summary>

  In this lab, we will convert the TLV code from our previous lab into Verilog using Python's Sandpiper-SaaS library. Once the conversion is complete, we'll develop a Verilog testbench to compare the waveforms generated by the MakerChip platform with those produced by the Verilog code in gtkwave.

Here are the steps required to convert TLV code to Verilog:

### Installation of necessary tools
Run the following commands in Ubuntu

**1. Install required packages**
```
 $ sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io
 $ sudo chmod 666 /var/run/docker.sock
 $ cd ~
 $ pip3 install pyyaml click sandpiper-saas
```
alternative commands
```
 $ sudo apt install make python python3 python3-pip git iverilog gtkwave
 $ sudo apt-get install python3-venv
 $ python3 -m venv .venv
 $ source ~/.venv/bin/activate
 $ pip3 install pyyaml click sandpiper-saas
```

**2. Clone the repository**
```
 $ cd
 $ git clone https://github.com/manili/VSDBabySoC.git
```

**3. Conversion of TL-Verilog code into Standard Verilog Code**
- __[TL-Verilog Code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv.tlv)__
  Place the TL-Verilog code provided into the VSDBabySoC/src/module directory
```
 $ cd VSDBabySoC
 $ sandpiper-saas -i ./src/module/*.tlv -o likith_riscv.v --bestsv --noline -p verilog --outdir ./src/module/
```
![Screenshot from 2024-08-27 00-39-01](https://github.com/user-attachments/assets/ff870aea-bdbb-48ea-b108-a57936ce323d)


**4. Run the Verilog code using iverilog**
  - __[Converted verilog code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv.v)__
  - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv_tb.v)__
    Place the test bench provided into the VSDBabySoC/src/module directory
```
 $ make pre_synth_sim 
 $ iverilog -o output/likith_riscv.out src/module/likith_riscv_tb.v -I src/include -I src/module
```
 If you encounter the following error, use this command:
 ![Screenshot from 2024-08-27 00-39-50](https://github.com/user-attachments/assets/56ea2bc8-9543-4321-a07f-df2847aecee4)

```
 $ iverilog -o output/likith_riscv.out -g2005-sv src/module/likith_riscv_tb.v -I src/include -I src/module
```

**5. Viewing waveforms in gtkwave**
```
 $ cd output
 $ ./likith_riscv.out
 $ gtkwave likith_riscv.vcd
```
**GTKWave:**
![Screenshot from 2024-08-27 02-51-21](https://github.com/user-attachments/assets/4dd9e539-5b01-4dea-b3c4-89417677bdf7)

**Makerchip:**
![Screenshot 2024-08-22 132714](https://github.com/user-attachments/assets/03bef1df-f7fa-47b8-a61e-51d67abe599f)

We successfully converted TLV code to Verilog using the Sandpiper-SaaS library and verified it by comparing waveforms from the MakerChip platform with those from the Verilog testbench in GTKWave

</details>


***


<details>
  <summary>LAB 7:  BabySoc Pre-synthesis simulation using iverilog GTKwave</summary>

Converting a digital output from a CPU into an analog signal using a DAC (Digital-to-Analog Converter) and PLL (Phase-Locked Loop)

**1. Clone the repository**
```
 $ cd
 $ git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation
```

```
$ cd BabySoC_Simulation
$ iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
$ ./pre_synth_sim.out
$ gtkwave pre_synth_sim.vcd
```



![Screenshot from 2024-09-01 20-29-55](https://github.com/user-attachments/assets/15ec732a-4d8b-4ba3-bee4-89fe1646a923)

#### PLL input and DAC Output
![Screenshot from 2024-09-01 20-28-29](https://github.com/user-attachments/assets/32aaca0f-8fac-47d8-af91-941817052c76)
![Screenshot from 2024-09-01 20-27-49](https://github.com/user-attachments/assets/10cce90c-48ff-4197-92d5-57e23ad9c4f8)

</details>





***





<details>
  <summary>LAB 8: RTL Design Using Verilog with SKY130 Technology</summary>

  <details>
    <summary>Day 0: Installation of Necessary Tools</summary>

  <details>
  <summary>Yosys</summary>

  ```
  git clone https://github.com/YosysHQ/yosys.git
  cd yosys-master 
  sudo apt install make 
  sudo apt-get install build-essential clang bison flex \libreadline-dev gawk tcl-dev libffi-dev git\
                  graphviz xdot pkg-config python3 libboost-system-dev\
                  libboost-python-dev libboost-filesystem-dev zlib1g-dev
  make 
  sudo make install
  ```
  ![Screenshot from 2024-10-21 22-12-50](https://github.com/user-attachments/assets/27a04214-1b02-4ea7-badb-f49ed93e2a97)
  </details>


  <details>
  <summary> iverilog </summary>
      
  ```
  sudo apt-get install iverilog
  ```
  ![Screenshot from 2024-10-21 22-35-40](https://github.com/user-attachments/assets/39891605-e818-4b24-b572-0f50aba3b67c)
  </details>

  <details>
  <summary> GTKWave </summary>
      
  ```
  sudo apt-get install gtkwave
  ```
  ![Screenshot from 2024-10-21 22-38-01](https://github.com/user-attachments/assets/2dfe40c5-521b-4b74-97ad-29da3ae00412)
  </details>

  </details>


  <details>
    <summary>Day 1: Introduction to Verilog RTL Design and Synthesis</summary>

### RTL Design
RTL (Register Transfer Level) design is the process of translating specifications into a functional representation of a digital circuit. It serves as an intermediary between high-level behavioral design and low-level gate-level design. RTL focuses on the data transfer between registers, abstracting away the specifics of gate and transistor implementations. Typically, RTL designs are described using Hardware Description Languages (HDLs) such as Verilog or VHDL.

### Test Bench
A test bench is used to provide stimuli to the design under test (DUT) and verify its functionality as specified in the Verilog description. It is written separately and includes the instantiation of the design that needs to be simulated. The test bench facilitates the validation of the design's performance and behavior.

![Screenshot from 2024-10-21 23-18-04](https://github.com/user-attachments/assets/a9ef82dd-2f23-4cb2-966a-ebcdd9dc34fe)

## Introduction to iverilog and GTKWave

### Iverilog
iverilog is an open-source tool for simulating and synthesizing Verilog designs. It is widely used for the design and verification of digital circuits described in the Verilog hardware description language (HDL).

### GTKWave
GTKWave is a widely-used open-source waveform viewer that enables users to visualize and analyze digital signal waveforms generated during circuit simulations. It is often paired with simulation tools like iverilog, providing a graphical representation of signal changes over time within a digital design.
  
![Screenshot from 2024-10-20 16-30-51](https://github.com/user-attachments/assets/ffec0429-8895-459c-9146-ce5482fa561f)

Lets simulate Mux using iverilog and GTKWave

- __[Mux verilog code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/good_mux.v)__
- __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_good_mux.v)__
      
  ```
  cd asic
  mkdir day1
  cd day1
  git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
  cd sky130RTLDesignAndSynthesisWorkshop
  cd verilog_files

  iverilog good_mux.v tb_good_mux.v
  ./a.out
  gtkwave tb_good_mux.vcd
  ```
![Screenshot from 2024-10-20 16-11-01](https://github.com/user-attachments/assets/d1f1f98b-cae3-4310-a781-9dadb95fcce2)
![Screenshot from 2024-10-20 16-11-12](https://github.com/user-attachments/assets/4d820473-d71a-4768-b964-9e82e8370cd6)
![Screenshot from 2024-10-20 23-48-02](https://github.com/user-attachments/assets/2053d4a8-7bf8-40a4-ad73-8ea6ccb406e7)

## Introduction Yosys
### Synthesis
Synthesis refers to the process of converting an RTL design, written in Verilog or another HDL, into a netlist that outlines the interconnections between components. This netlist is intended to perform the same function as the original HDL code. A synthesizer is the tool that facilitates this conversion, with Yosys being one such example.

### Yosys
Yosys is a tool designed to transform high-level hardware descriptions into optimized gate-level representations suitable for various FPGA and ASIC technologies. The typical workflow involves providing Yosys with the RTL design and a .lib file containing standard library cells. Yosys then synthesizes this information to produce a netlist file.

**Flow of Yosys Synthesis:**
![Screenshot from 2024-10-22 00-17-52](https://github.com/user-attachments/assets/b877e5b4-d29f-4504-b2ae-6adc5fd5a909)


![Screenshot from 2024-10-20 20-01-46](https://github.com/user-attachments/assets/a60ddc37-0141-4008-a933-6db4714472ea)

**Commands to Synthesize a design using Yosys:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog good_mux.v
synth -top good_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show 
write_verilog -noattr good_mux_netlist.v
!gedit good_mux_netlist.v 
  ```
![Screenshot from 2024-10-20 20-19-56](https://github.com/user-attachments/assets/8af64f7c-2811-4e81-88eb-e25cc8f36b2f)

**Synthesized Mux circuit:**
![Screenshot from 2024-10-20 20-20-07](https://github.com/user-attachments/assets/91d3f703-63b8-45e2-b692-b73e08d8d106)


![Screenshot from 2024-10-20 20-26-00](https://github.com/user-attachments/assets/26c36673-55c1-4202-9dcd-50f6b89e3e98)

**Synthesized Mux Netlist:**
- __[Mux Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/good_mux_netlist.v)__
![Screenshot from 2024-10-20 23-19-03](https://github.com/user-attachments/assets/d672aa35-e1c8-4598-a503-2ada759a0c9b)


  </details>


  <details>
    <summary>Day 2: Timing libs, Hierarchial vs Flat Synthesis and efficient flop coding styles</summary>
    
## Hierarchical synthesis and flat synthesis

 - __[Multiple Modules](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/multiple_modules.v)__
  
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_modules.v
synth -top multiple_modules
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show multiple_modules
write_verilog -noattr multiple_modules_hier.v
!gedit multiple_modules_hier.v 
  ```

  ```
module sub_module2 (input a, input b, output y);
	assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
	assign y = a&b;
endmodule

module multiple_modules (input a, input b, input c , output y);
	wire net1;
	sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
	sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule
  ```

![20241021_202206068_iOS](https://github.com/user-attachments/assets/4db6366d-1437-4c3d-b104-8408b64484bf)

Yosys synthesizer generates the following schematic instead of the above one
![Screenshot from 2024-10-21 02-34-52](https://github.com/user-attachments/assets/478f61b9-80de-4389-81e4-1f1af5c4c51d)

**Hierarchial synthesis:** In the hierarchial synthesis the hierarchies are preserved. We can see the sub_module1(u1) and sub_module2 (u2) as above. The hierarchial netlist code is given below.
- __[Hierarchial synthesis](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/multiple_modules_hier.v)__
![Screenshot from 2024-10-22 01-27-46](https://github.com/user-attachments/assets/7800db08-14e6-4df6-81c1-e5e8ddcf1f73)

**Flattened netlist:** In flattened netlist, the hierarcies are flattend out and there is single module i.e, gates are instantiated directly instead of sub_modules.
**Commands to flatten the given design:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_modules.v
synth -top multiple_modules
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
flatten
show
write_verilog -noattr multiple_modules_hier.v
!gedit multiple_modules_hier.v 
  ```
**Flattend Design and Netlist:**
![Screenshot from 2024-10-21 02-52-30](https://github.com/user-attachments/assets/0db63dba-9d07-43de-9b8a-5c00c3471a4f)
- __[Flettened Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/multiple_modules_hier%20(flattend).v)__
![Screenshot from 2024-10-22 01-36-42](https://github.com/user-attachments/assets/2cc4a018-4161-4a31-96b9-8f724d247f18)


**Why Is Submodule Level Synthesis Important?**
- Submodule level synthesis is advantageous when dealing with multiple instances of the same module. Instead of synthesizing the same module repeatedly, we can synthesize it once and then replicate the resulting netlist as needed, effectively assembling it into the top module's netlist.
- This approach also embodies a "divide and conquer" strategy. For large designs, synthesis tools may struggle to optimize effectively. By breaking the design into smaller parts and synthesizing them individually, we can achieve optimized netlists for each section, which can then be combined to form the complete top module netlist.
  

**Commands to Submodule Level Synthesis:**
  
  ```
  cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
  yosys
  read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
  read_verilog multiple_modules.v
  synth -top sub_module1
  abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
  show
  ```
  ![Screenshot from 2024-10-21 02-59-06](https://github.com/user-attachments/assets/33346966-72d6-4b18-a097-27078fb33878)
  

## Various Flop Coding Styles and Optimization

### Flop coding styles
- Asynchronous reset
- Asynchronous set
- Synchronous reset
- Synchronous set
- Both Asynchronous reset and Synchronous reset
- Both Asynchronous set and Synchronous set

### D Flipflop Asynchronous reset

**D Flipflop Asynchronous reset Simulation:**
 - __[Design](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/dff_asyncres.v)__
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_asyncres.v)__
  ```
 cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
 iverilog dff_asyncres.v tb_dff_asyncres.v
 ./a.out
 gtkwave tb_dff_asyncres.vcd
  ```
  ![Screenshot from 2024-10-21 03-23-51](https://github.com/user-attachments/assets/4c31c7d0-5fa9-485b-a82c-afe525abc95c)


**D Flipflop Asynchronous reset Synthesis:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_asyncres.v
synth -top dff_asyncres
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![ar](https://github.com/user-attachments/assets/dc676871-d204-4372-951d-732b68800b66)


### D Flipflop Asynchronous Set
**D Flipflop Asynchronous Set Simulation:**
 - __[Design](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/dff_async_set.v)__
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_async_set.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_async_set.v tb_dff_async_set.v 
./a.out
gtkwave tb_dff_async_set.vcd
  ```
 ![Screenshot from 2024-10-21 03-28-37](https://github.com/user-attachments/assets/75fc9004-6baf-4297-9539-6fe8ac43951b)


**D Flipflop Asynchronous Set Synthesis:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_async_set.v
synth -top dff_async_set
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![as](https://github.com/user-attachments/assets/c83da979-062c-4f22-a138-964710fb2b02)



### D Flipflop Synchronous Reset
**D Flipflop Synchronous Reset Simulation:**
 - __[Design](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/dff_syncres.v)__
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_syncres.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_syncres.v tb_dff_syncres.v
./a.out
gtkwave tb_dff_syncres.vcd
  ```
![Screenshot from 2024-10-21 03-32-22](https://github.com/user-attachments/assets/41684bc9-5f32-4ce7-a190-f04304e7f026)



**D Flipflop Synchronous Reset Synthesis:**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_syncres.v
synth -top dff_syncres
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```



![sr](https://github.com/user-attachments/assets/7c8a7835-b3fb-4610-a064-0366067f7858)



## Optimization

When we perform synthesis yosys optimise the circuit based on the logic.
### Example1:
  ```
module mul2 (input [2:0] a, output [3:0] y);
assign y = a * 2;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog mult_2.v
synth -top mul2
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr mult2_net.v
!gedit mult2_net.v
  ```

 ![20241022_013453528_iOS](https://github.com/user-attachments/assets/25ae9463-63dc-45fc-9fae-bc0f82ea1828)

 - __[Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/mult2_net.v)__
![Screenshot from 2024-10-22 02-45-48](https://github.com/user-attachments/assets/bf811bbe-e248-4653-b26f-bc3437a52357)

### Example2:
  ```
module mult8 (input [2:0] a , output [5:0] y);
assign y = a * 9;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog mult_8.v
synth -top mult8
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr mult8_net.v
!gedit mult8_net.v
  ```

 ![20241022_013513573_iOS](https://github.com/user-attachments/assets/04b65c35-baa8-4ea0-a8a0-f9aecb00aa33)

 - __[Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/mult8_net.v)__
![Screenshot from 2024-10-22 02-55-04](https://github.com/user-attachments/assets/c055e177-e620-4807-9099-0879927411e7)

  </details>



  <details>
    <summary>Day 3: Combinational and Sequential Optimization</summary>

## Combinational Logic Optimization
- Squeezing the logic to get the most optimised design
  - Area and Power savings
- Constant Propagation
   - Direct Optimisaton
- Boolean Logic Optimisation
  - K-Map
  - Quine McKluskey

    ![20241021_224028450_iOS](https://github.com/user-attachments/assets/f359cb2e-8712-4d00-b69b-ebc8fefc97a0)
    ![20241021_224100665_iOS](https://github.com/user-attachments/assets/ca73b9a0-9975-4df2-a24d-c3a790166423)

`opt_clean -purge` is used to optimize the synthesized design.   


### Example1
 ```
module opt_check (input a , input b , output y);
assign y = a?b:0;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check.v
synth -top opt_check
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![1](https://github.com/user-attachments/assets/4e7c6033-c28f-4cf2-abbe-fc47bbf6f075)

**output is optimized to y = ab**

![Screenshot from 2024-10-21 05-47-26](https://github.com/user-attachments/assets/4f30b904-9ed3-4318-9406-c3d4267b98a8)




### Example2
 ```
module opt_check2 (input a , input b , output y);
assign y = a?1:b;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check2.v
synth -top opt_check2
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![2](https://github.com/user-attachments/assets/9a43bd46-78b7-47c3-8d05-c6e70abc42ce)

**output is optimized to y = a + b**

![Screenshot from 2024-10-21 05-49-17](https://github.com/user-attachments/assets/cd9fdbde-01a1-4298-a634-f0bd7cbbffb6)



### Example3
 ```
module opt_check3 (input a , input b, input c , output y);
assign y = a?(c?b:0):0;
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check3.v
synth -top opt_check3
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![3](https://github.com/user-attachments/assets/c62b2c54-8480-4d4d-a1f5-f5ee8e1f16a7)

**output is optimized to y = abc**

![Screenshot from 2024-10-21 05-52-32](https://github.com/user-attachments/assets/499c63b6-8001-4828-bf3a-743f4e49115c)



### Example4
 ```
module opt_check4 (input a , input b , input c , output y);
assign y = a?(b?(a & c ):c):(!c);
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog opt_check4.v
synth -top opt_check4
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![4](https://github.com/user-attachments/assets/60976e4d-518d-4141-b1ae-3ba063858e1a)

**output is optimized to y = xnor(a,c)**

![Screenshot from 2024-10-21 05-54-38](https://github.com/user-attachments/assets/5764cb0f-b072-48a7-9529-4866051548c1)

If there are multiple modules in the design -> First flatten then Optimize

### Example5
 ```
module sub_module1(input a , input b , output y);
assign y = a & b;
endmodule

module sub_module2(input a , input b , output y);
assign y = a^b;
endmodule

module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;
sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));
assign y = c | (b & n1); 
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_module_opt.v
synth -top multiple_module_opt
show multiple_module_opt
write_verilog -noattr multiple_module_opt_hier.v
flatten
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
**Before and After Optimization:**

![Screenshot from 2024-10-22 04-39-38](https://github.com/user-attachments/assets/cdb83320-c7c7-4940-bf77-5719dccfab22)

### Example6
 ```
module sub_module(input a , input b , output y);
assign y = a & b;
endmodule

module multiple_module_opt2(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
sub_module U2 (.a(b), .b(c) , .y(n2));
sub_module U3 (.a(n2), .b(d) , .y(n3));
sub_module U4 (.a(n3), .b(n1) , .y(y));
endmodule
  ```

  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_module_opt2.v
synth -top multiple_module_opt2
show multiple_module_opt2
write_verilog -noattr multiple_module_opt2_hier.v
flatten
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
**Before and After Optimization:**

![Screenshot from 2024-10-22 04-43-03](https://github.com/user-attachments/assets/97bd6f70-948b-458e-98c6-e2b9dece2e61)


## Sequential Logic Optimization
- Basic
   - Sequential Constant propagation
- Advanced [Not covered as part of Lab]
  - State optimisation
  - Retiming
  - Sequential Logic Cloning (Floor Plan Aware Synthesis)

### Example1
**Design**
 ```
module dff_const1(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const1.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const1.v tb_dff_const1.v
./a.out
gtkwave tb_dff_const1.vcd
  ```
![Screenshot from 2024-10-21 07-20-01](https://github.com/user-attachments/assets/51cfc7c0-6b4c-4172-ac1e-6cd0cd190758)

**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const1.v
synth -top dff_const1
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 06-54-21](https://github.com/user-attachments/assets/23476912-e7c7-4c39-9b61-0a0b283936a9)

### Example2
**Design**
 ```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const2.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const2.v tb_dff_const2.v
./a.out
gtkwave tb_dff_const2.vcd
  ```
![Screenshot from 2024-10-21 06-49-38](https://github.com/user-attachments/assets/aac19038-7765-4d2b-87d7-8ef4ec5e2333)


**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const2.v
synth -top dff_const2
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 06-56-35](https://github.com/user-attachments/assets/3945e225-4f1e-4f54-83b0-fb796f4bdb56)



### Example3
**Design**
 ```
module dff_const3(input clk, input reset, output reg q);
reg q1;
always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const3.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const3.v tb_dff_const3.v
./a.out
gtkwave tb_dff_const3.vcd
  ```
![Screenshot from 2024-10-21 07-09-33](https://github.com/user-attachments/assets/2bf8f6e0-a9a7-4e57-9bd6-cd98e76ddd7b)



**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const3.v
synth -top dff_const3
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 07-10-34](https://github.com/user-attachments/assets/77d584cd-3edc-4be7-b5bc-a3926218bc23)



### Example4
**Design**
 ```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const4.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const4.v tb_dff_const4.v
./a.out
gtkwave tb_dff_const4.vcd
  ```
![Screenshot from 2024-10-21 07-14-20](https://github.com/user-attachments/assets/8ffde49d-905e-4072-af9e-db41718aa579)



**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const4.v
synth -top dff_const4
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 07-15-05](https://github.com/user-attachments/assets/71471e46-0674-46fc-bde8-087e532743d8)



### Example5
**Design**
 ```
module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_dff_const5.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog dff_const5.v tb_dff_const5.v
./a.out
gtkwave tb_dff_const5.vcd
  ```
![Screenshot from 2024-10-21 07-16-25](https://github.com/user-attachments/assets/4e4c5cfa-728d-47c3-b541-5de43e6d4efa)




**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog dff_const5.v
synth -top dff_const5
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```
![Screenshot from 2024-10-21 07-16-37](https://github.com/user-attachments/assets/686dc833-6a01-4567-960b-2361d2df6fc1)


### Optimization for Unsed Outputs

### Example1
**Design**
 ```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[0];

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end
endmodule
 ```

**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog counter_opt.v
synth -top counter_opt
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```

![Screenshot from 2024-10-21 07-33-04](https://github.com/user-attachments/assets/e6bbe891-7900-4886-afaa-9a0e77cf7fbc)



### Example2
**Design**
 ```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = (count[2:0] == 3'b100);
always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end
endmodule
 ```

**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog counter_opt2.v
synth -top counter_opt
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
  ```

![Screenshot from 2024-10-21 07-43-10](https://github.com/user-attachments/assets/6c07d587-1783-4396-af80-5b49cfe236e6)




  </details>


  <details>
    <summary>Day 4: GLS, Blocking vs Non-Blocking and Synthesis-Simulation mismatch</summary>

## Gate Level Simulation

**What is GLS?**
- Running the test bench with Netlist as Design Under Test
- Netlist is logically same as RTL Code.
  - Same Test Bench will align with the Design.

**Why GLS?**
- Verify the logical correctness of design after synthesis
- Ensuring the timing of the design is met.

![Screenshot from 2024-10-21 07-52-05](https://github.com/user-attachments/assets/03e77024-b77e-480e-9f7a-fbf2347acbc6)
  
### Synthesis Simulation Mismatch

- Missing sensitivity list in always block
- Blocking vs Non-Blocking Assignments
- Non standard Verilog coding

  
### Example1: Good_Mux
**Design**
 ```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
	assign y = sel?i1:i0;
	endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_ternary_operator_mux.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog ternary_operator_mux.v tb_ternary_operator_mux.v
./a.out
gtkwave tb_ternary_operator_mux.vcd
  ```
![Screenshot from 2024-10-21 08-23-44](https://github.com/user-attachments/assets/e6d8b4bb-6346-4da6-bed7-3541caf96eb7)




**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog ternary_operator_mux.v
synth -top ternary_operator_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
write_verilog -noattr ternary_operator_mux_net.v
show
  ```

![Screenshot from 2024-10-21 08-25-40](https://github.com/user-attachments/assets/e0070eec-3796-472d-905c-fb476d84fc94)


**Gate Level Simulation**
 - __[Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/ternary_operator_mux_net.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v
./a.out
gtkwave tb_ternary_operator_mux.vcd
  ```
![Screenshot from 2024-10-21 08-33-55](https://github.com/user-attachments/assets/ecd5676d-6652-47bf-8aec-a897c556e16e)

Here RTL Simulation and Gate Level Simulation are matching, hence the mux design is a good.


  
### Example2: 
**Design**
 ```
module bad_mux (input i0 , input i1 , input sel , output reg y);
always @ (sel)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_bad_mux.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog bad_mux.v tb_bad_mux.v
./a.out
gtkwave tb_bad_mux.vcd
  ```
![Screenshot from 2024-10-21 08-37-48](https://github.com/user-attachments/assets/a5d4d454-46bc-4225-88ec-406495f42b2b)




**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog bad_mux.v
synth -top bad_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
write_verilog -noattr bad_mux_net.v
show
  ```

![Screenshot from 2024-10-21 08-39-43](https://github.com/user-attachments/assets/60139c73-6e1a-46fb-a1b1-196faaf79bf1)


**Gate Level Simulation**
 - __[Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/bad_mux_net.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v bad_mux_net.v tb_bad_mux.v
./a.out
gtkwave tb_bad_mux.vcd
  ```
![Screenshot from 2024-10-21 08-42-13](https://github.com/user-attachments/assets/8a1ad4a0-bbe4-4891-a843-98790b184efe)

Here RTL Simulation and Gate Level Simulation are NOT matching, i.e., **Synthesis-Simulation Mismatch** has occured, hence the given mux design is bad. 


 
### Example3: 
**Design**
 ```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
begin
	d = x & c;
	x = a | b;
end
endmodule
  ```

**Simulation**
 - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/tb_blocking_caveat.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog blocking_caveat.v tb_blocking_caveat.v
./a.out
gtkwave tb_blocking_caveat.vcd
  ```
![Screenshot from 2024-10-21 08-56-35](https://github.com/user-attachments/assets/12b02319-1050-44c5-9933-a6c2846790a5)





**Synthesis**
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog blocking_caveat.v
synth -top blocking_caveat
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
write_verilog -noattr blocking_caveat_net.v
show
  ```

![Screenshot from 2024-10-21 08-59-40](https://github.com/user-attachments/assets/64550f5c-c1e5-472e-aecd-6f9732d3e5f7)


**Gate Level Simulation**
 - __[Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/blocking_caveat_net.v)__
  ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v
./a.out
gtkwave tb_blocking_caveat.vcd
  ```
![Screenshot from 2024-10-21 09-00-43](https://github.com/user-attachments/assets/b0d3acc5-6ead-4ae6-b715-96b23fd9f342)


Here RTL Simulation and Gate Level Simulation are NOT matching, i.e., **Synthesis-Simulation Mismatch** has occured due to Blocking Statements.  

  </details>

<details>
  <summary>Synthesizing RISC-V with Yosys</summary>

 Add the following supporting files for RISC-V to the `verilog_files` folder: `likith_riscv.v`, `likith_riscv_gen.v`, `clk_gate.v`, `sandpiper.vh`, `sp_verilog.vh`, and `sandpiper_gen.vh`.

 ### Commands to Synthesize RISC-V with Yosys
   ```
cd /home/likith/asic/day1/sky130RTLDesignAndSynthesisWorkshop/verilog_files
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog likith_riscv.v 
read_verilog clk_gate.v 
synth -top RV_CPU
flatten
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
write_verilog -noattr likith_riscv_net.v
show RV_CPU
  ```
 __[RISC-V Synthesized Design Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%208/RISCV/likith_riscv_net.v)__

</details>
</details>




***




<details>
  <summary>LAB 9:  RISC-V Synthesis for Gate-Level Simulation of BabySoC</summary>

## Synthesis of RISCV Core

- Create the directory by running `mkdir -p /home/likith/lab9/synthesis`.
- Download and add the files from [this folder](https://github.com/thelikith/asic-design-class/tree/main/Codes/Lab%209/Synthesis) to the synthesis folder.

**Commands for Synthesis:**
  ```
cd /home/likith/lab9/synthesis
yosys
read_liberty -lib sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog rvmyth.v 
read_verilog clk_gate.v 
synth -top rvmyth
abc -liberty sky130_fd_sc_hd__tt_025C_1v80.lib 
write_verilog -noattr rvmyth_netlist.v
show rvmyth
  ```

**[RISC-V Design Netlist](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%209/rvmyth_netlist.v)**

After synthesizing the RISC-V core, we will integrate the resulting netlist into BabySoC for simulation. This process is called as Post-Synthesis Simulation or Gate-Level Simulation.

## BabySoC Post Synthesis Simulation

**Commands for Gate-Level Simulation:**
  ```
cd /home/likith/lab9
git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation
cd BabySoC_Simulation
  ```
- Copy the generated netlist file to `/home/likith/lab9/BabySoC_Simulation/src/module`
- Add the files `primitives.v` and `sky130_fd_sc_hd.v` from [this folder](https://github.com/thelikith/asic-design-class/tree/main/Codes/Lab%209/Synthesis) to the directory `/home/likith/lab9/BabySoC_Simulation/src/module`.
- Replace the testbench in `/home/likith/lab9/BabySoC_Simulation/src/module` with this [testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%209/testbench.v)
  
```
cd src/module
iverilog -o post_synth.out primitives.v sky130_fd_sc_hd.v testbench.v -D POST_SYNTH_SIM
./post_synth.out
gtkwave post_synth_sim.vcd
```
![Screenshot from 2024-10-24 03-01-43](https://github.com/user-attachments/assets/66da4c43-c4e3-4ac6-be4b-9a1d8b907218)

**Post-Synthesis Simulation Results:**

![Screenshot from 2024-10-24 02-46-35](https://github.com/user-attachments/assets/8af59f82-d83c-4a92-a007-7a304eb4fcb3)
![Screenshot from 2024-10-24 02-47-15](https://github.com/user-attachments/assets/c5008f36-3557-4708-b53b-ee5dd0f99440)



**Pre-Synthesis Simulation Result from Lab 7:**
![Screenshot from 2024-09-01 20-27-49](https://github.com/user-attachments/assets/f1ef42f8-8412-4bf4-bdad-f2437e8c5f05)

The Post-Synthesis Simulation Results and Pre-Synthesis Simulation Results have been verified.


</details>




***



<details>
  <summary>LAB 10: Static Timing Analysis for a Synthesized RISC-V Core with OpenSTA </summary>

## Tools Installation
**CUDD**
Download CUDD from **[here](https://github.com/davidkebo/cudd/blob/main/cudd_versions/cudd-3.0.0.tar.gz)** and move downloaded file to `home` directory
```
cd
tar xvfz cudd-3.0.0.tar.gz
cd cudd-3.0.0
./configure
make
```
**openSTA**
```
cd
sudo apt-get install cmake clang gcc tcl swig bison flex

git clone https://github.com/parallaxsw/OpenSTA.git
cd OpenSTA
cmake -DCUDD_DIR=/home/likith/cudd-3.0.0
make
app/sta
```

![Screenshot from 2024-10-28 18-53-19](https://github.com/user-attachments/assets/1cac049f-f06a-4f7d-8416-bbbc0a9a6835)

```
cd /home/likith/OpenSTA
mkdir lab10
```
Download all the **[required files](https://github.com/thelikith/asic-design-class/tree/main/Codes/Lab%2010)** to directory `lab10`

**Steps to do Timing Analysis**
- Clock period = 9.45ns
- Setup uncertainty and clock transition is 5% of clock
- Hold uncertainty and data transition is 8% of clock. 

```
cd /home/likith/OpenSTA/app
./sta

read_liberty /home/likith/OpenSTA/lab10/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog /home/likith/OpenSTA/lab10/likith_riscv_netlist.v
link_design rvmyth

create_clock -name clk -period 9.45 [get_ports clk]
set_clock_uncertainty [expr 0.05 * 9.45] -setup [get_clocks clk]
set_clock_uncertainty [expr 0.08 * 9.45] -hold [get_clocks clk]
set_clock_transition [expr 0.05 * 9.45] [get_clocks clk]
set_input_transition [expr 0.08 * 9.45] [all_inputs]

report_checks -path_delay max
report_checks -path_delay min
```
![Screenshot from 2024-10-28 18-31-32](https://github.com/user-attachments/assets/6ce2808f-3494-4beb-b485-94139a3b4bf6)   
![Screenshot from 2024-10-28 18-31-55](https://github.com/user-attachments/assets/0981c146-78ff-4d4c-b0da-e522926fd982)
![Screenshot from 2024-10-28 18-32-01](https://github.com/user-attachments/assets/7763f3f1-5479-44cc-9eeb-9cbde27ea740)


</details>


***




<details>
  <summary>LAB 11: Static Timing Analysis for the synthesized VSDBabySoC with OpenSTA </summary>

### Download all the necessary libraries.
```
cd /home/likith/OpenSTA
mkdir lab11
cd lab11
mkdir lib
mkdir output
```

- Download and copy the files from this **[folder](https://github.com/Subhasis-Sahu/SFAL-VSD/tree/main/skywater-pdk-libs-sky130_fd_sc_hd/timing)** to `lib` directory
- Download and copy the files from this **[folder](https://github.com/manili/VSDBabySoC/tree/main/src/lib)** to `lib` directory
- Download `sta.tcl`, `vsdbabysoc_synth.v`, `vsdbabysoc_synthesis.sdc`  from **[here](https://github.com/thelikith/asic-design-class/tree/main/Codes/Lab%2011)** to `lab11` directory


### vsdbabysoc_synthesis.sdc
- Clock period = 9.45ns
- Setup uncertainty and clock transition is 5% of clock
- Hold uncertainty and data transition is 8% of clock. 
```
# Create clock with new period
create_clock [get_pins pll/CLK] -name clk -period 9.45 -waveform {0 4.725}

# Set loads
set_load -pin_load 0.5 [get_ports OUT]
set_load -min -pin_load 0.5 [get_ports OUT]

# Set clock latency
set_clock_latency 1 [get_clocks clk]
set_clock_latency -source 2 [get_clocks clk]

# Set clock uncertainty
set_clock_uncertainty 0.4725 [get_clocks clk]  ; # 5% of clock period for setup
set_clock_uncertainty -hold 0.756 [get_clocks clk] ; # 8% of clock period for hold

# Set maximum delay
set_max_delay 9.45 -from [get_pins dac/OUT] -to [get_ports OUT]

# Set input delay for VCO_IN
set_input_delay -clock clk -max 4 [get_ports VCO_IN]
set_input_delay -clock clk -min 1 [get_ports VCO_IN]

# Set input delay for ENb_VCO
set_input_delay -clock clk -max 4 [get_ports ENb_VCO]
set_input_delay -clock clk -min 1 [get_ports ENb_VCO]

# Set input delay for ENb_CP
set_input_delay -clock clk -max 4 [get_ports ENb_CP]
set_input_delay -clock clk -min 1 [get_ports ENb_CP]

# Set input transition for VCO_IN
set_input_transition -max 0.4725 [get_ports VCO_IN] ; # 5% of clock
set_input_transition -min 0.756 [get_ports VCO_IN] ; # adjust if needed

# Set input transition for ENb_VCO
set_input_transition -max 0.4725 [get_ports ENb_VCO] ; # 5% of clock
set_input_transition -min 0.756 [get_ports ENb_VCO] ; # adjust if needed

# Set input transition for ENb_CP
set_input_transition -max 0.4725 [get_ports ENb_CP] ; # 5% of clock
set_input_transition -min 0.756 [get_ports ENb_CP] ; # adjust if needed
```


### sta.tcl
```
set list_of_lib_files(1) "sky130_fd_sc_hd__tt_025C_1v80.lib"
set list_of_lib_files(2) "sky130_fd_sc_hd__tt_100C_1v80.lib"
set list_of_lib_files(3) "sky130_fd_sc_hd__ff_100C_1v65.lib"
set list_of_lib_files(4) "sky130_fd_sc_hd__ff_100C_1v95.lib"
set list_of_lib_files(5) "sky130_fd_sc_hd__ff_n40C_1v56.lib"
set list_of_lib_files(6) "sky130_fd_sc_hd__ff_n40C_1v65.lib"
set list_of_lib_files(7) "sky130_fd_sc_hd__ff_n40C_1v76.lib"
set list_of_lib_files(8) "sky130_fd_sc_hd__ff_n40C_1v95.lib"
set list_of_lib_files(9) "sky130_fd_sc_hd__ss_100C_1v40.lib"
set list_of_lib_files(10) "sky130_fd_sc_hd__ss_100C_1v60.lib"
set list_of_lib_files(11) "sky130_fd_sc_hd__ss_n40C_1v28.lib"
set list_of_lib_files(12) "sky130_fd_sc_hd__ss_n40C_1v35.lib"
set list_of_lib_files(13) "sky130_fd_sc_hd__ss_n40C_1v40.lib"
set list_of_lib_files(14) "sky130_fd_sc_hd__ss_n40C_1v44.lib"
set list_of_lib_files(15) "sky130_fd_sc_hd__ss_n40C_1v60.lib"
set list_of_lib_files(16) "sky130_fd_sc_hd__ss_n40C_1v76.lib"

for {set i 1} {$i <= [array size list_of_lib_files]} {incr i} {
read_liberty /home/likith/OpenSTA/lab11/lib/$list_of_lib_files($i)
read_liberty -min /home/likith/OpenSTA/lab11/lib/avsdpll.lib
read_liberty -max /home/likith/OpenSTA/lab11/lib/avsdpll.lib
read_liberty -min /home/likith/OpenSTA/lab11/lib/avsddac.lib
read_liberty -max /home/likith/OpenSTA/lab11/lib/avsddac.lib
read_verilog  /home/likith/OpenSTA/lab11/vsdbabysoc_synth.v
link_design vsdbabysoc
read_sdc /home/likith/OpenSTA/lab11/vsdbabysoc_synthesis.sdc
check_setup -verbose
report_checks -path_delay min_max -fields {nets cap slew input_pins fanout} -digits {4} > /home/likith/OpenSTA/lab11/output/min_max_$list_of_lib_files($i).txt

exec echo "$list_of_lib_files($i)" >> /home/likith/OpenSTA/lab11/output/sta_worst_max_slack.txt
report_worst_slack -max -digits {4} >> /home/likith/OpenSTA/lab11/output/sta_worst_max_slack.txt

exec echo "$list_of_lib_files($i)" >> /home/likith/OpenSTA/lab11/output/sta_worst_min_slack.txt
report_worst_slack -min -digits {4} >> /home/likith/OpenSTA/lab11/output/sta_worst_min_slack.txt

exec echo "$list_of_lib_files($i)" >> /home/likith/OpenSTA/lab11/output/sta_tns.txt
report_tns -digits {4} >> /home/likith/OpenSTA/lab11/output/sta_tns.txt

exec echo "$list_of_lib_files($i)" >> /home/likith/OpenSTA/lab11/output/sta_wns.txt
report_wns -digits {4} >> /home/likith/OpenSTA/lab11/output/sta_wns.txt
}

```

### Commands to perform STA
```
cd /home/likith/OpenSTA/app
./sta
source /home/likith/OpenSTA/lab11/sta.tcl
```

![Screenshot from 2024-11-04 22-10-19](https://github.com/user-attachments/assets/82f75b08-05b9-4b6f-9821-577f1a82385b)


| Library File                          |         TNS         |         WNS         |     Worst Max Slack (or) Worst Setup Slack    |     Worst Min Slack (or) Worst Hold Slack     |
|---------------------------------------|:-------------------:|:-------------------:|:----------------------:|:-------------------------:|
| sky130_fd_sc_hd__tt_025C_1v80.lib    |       -2.3908       |       -0.0833       |         -0.0833        |          -0.4464         |
| sky130_fd_sc_hd__tt_100C_1v80.lib    |        0.0000       |        0.0000       |          0.0710        |          -0.4415         |
| sky130_fd_sc_hd__ff_100C_1v65.lib    |        0.0000       |        0.0000       |          2.0320        |          -0.5069         |
| sky130_fd_sc_hd__ff_100C_1v95.lib    |        0.0000       |        0.0000       |          3.5443        |          -0.5600         |
| sky130_fd_sc_hd__ff_n40C_1v56.lib    |        0.0000       |        0.0000       |          0.2556        |          -0.4645         |
| sky130_fd_sc_hd__ff_n40C_1v65.lib    |        0.0000       |        0.0000       |          1.3887        |          -0.5009         |
| sky130_fd_sc_hd__ff_n40C_1v76.lib    |        0.0000       |        0.0000       |          2.4076        |          -0.5317         |
| sky130_fd_sc_hd__ff_n40C_1v95.lib    |        0.0000       |        0.0000       |          3.5694        |          -0.5685         |
| sky130_fd_sc_hd__ss_100C_1v40.lib    |     -3305.4478      |      -19.1441       |        -19.1441        |           0.1493         |
| sky130_fd_sc_hd__ss_100C_1v60.lib    |     -1352.3196      |       -9.8965       |         -9.8965        |          -0.1140         |
| sky130_fd_sc_hd__ss_n40C_1v28.lib    |    -15136.6904      |      -64.5857       |        -64.5857        |           1.0736         |
| sky130_fd_sc_hd__ss_n40C_1v35.lib    |     -9084.4893      |      -41.7195       |        -41.7195        |           0.5915         |
| sky130_fd_sc_hd__ss_n40C_1v40.lib    |     -6459.7271      |      -31.7162       |        -31.7162        |           0.3689         |
| sky130_fd_sc_hd__ss_n40C_1v44.lib    |     -5001.8486      |      -25.9304       |        -25.9304        |           0.2349         |
| sky130_fd_sc_hd__ss_n40C_1v60.lib    |     -1876.7622      |      -12.6315       |        -12.6315        |          -0.0932         |
| sky130_fd_sc_hd__ss_n40C_1v76.lib    |      -735.8080      |       -6.4044       |         -6.4044        |          -0.2522         |

![Figure_1](https://github.com/user-attachments/assets/24914d62-569e-4d14-a320-41c5067143d1)
![Figure_2](https://github.com/user-attachments/assets/531d5e57-490a-4e76-ae34-e7c2afa9be60)




</details>




***



<details>
  <summary>LAB 12:  Advanced Physical Design using OpenLANE</summary>

## Inception of open-source EDA, OpenLANE and Sky130 PDK

**1. Run 'picorv32a' design synthesis using OpenLANE flow and generate necessary outputs.**

```
cd Desktop/work/tools/openlane_working_dir/openlane
docker
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
run_synthesis
exit
exit
```
![Screenshot from 2024-11-13 19-34-07](https://github.com/user-attachments/assets/4a5330cc-40be-4d18-bdd1-c77972b8f371)
![Screenshot from 2024-11-13 19-43-57](https://github.com/user-attachments/assets/3d4ea0e9-00aa-4ed9-9c5e-26775fd990e6)

**2. Calculate the flop ratio.**
![Screenshot from 2024-11-13 19-53-41](https://github.com/user-attachments/assets/4aee2a20-be89-4ca9-88ab-e07b9493783c)


**Calculation of Flop Ratio and DFF % from Synthesis Statistics Report**

$$
\text{Flop Ratio} = \frac{1613}{14876} = 0.108429685
$$

$$
\text{Percentage of DFF's} = 0.108429685 \times 100 = 10.84296854 \%
$$



## Good floorplan vs bad floorplan and introduction to library cells
**1. Run 'picorv32a' design floorplan using OpenLANE flow and generate necessary outputs.**

```
cd Desktop/work/tools/openlane_working_dir/openlane
docker
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
run_synthesis
run_floorplan
```

![Screenshot from 2024-11-13 23-38-00](https://github.com/user-attachments/assets/aa2f9642-5168-45ff-8d17-1a658009c4a8)



**2. Calculate the die area in microns from the values in floorplan def.**

![Screenshot from 2024-11-13 23-54-26](https://github.com/user-attachments/assets/0ff3cda6-41c6-4136-bc06-db5a152fc6de)


- **Unit distance** = 1 micron
- **Die width in unit distance** = 660685
- **Die height in unit distance** = 671405


$$
\text{Distance in microns} = \frac{\text{Value in Unit Distance}}{1000}
$$


$$
\text{Die width in microns} = \frac{660685}{1000} = 660.685 \ \text{microns}
$$


$$
\text{Die height in microns} = \frac{671405}{1000} = 671.405 \ \text{microns}
$$


$$
\text{Area of Die in microns} = 660.685 \times 671.405 = 443587.212425 \ \text{square microns}
$$


**3. Load generated floorplan def in magic tool and explore the floorplan.**
```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_18-05/results/floorplan/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def &
```

**4. Run 'picorv32a' design congestion aware placement using OpenLANE flow and generate necessary outputs.**
```
run_placement
```
![Screenshot from 2024-11-14 00-31-39](https://github.com/user-attachments/assets/8d0b13e6-5116-4b1c-bd7f-28f9e39b3a1b)

**5. Load generated placement def in magic tool and explore the placement.**

```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/13-11_18-44/results/placement/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
```


## Design library cell using Magic Layout and ngspice characterization

**1. Clone custom inverter standard cell design from github repository**

```
cd
cd Desktop/work/tools/openlane_working_dir/openlane
git clone https://github.com/nickson-jose/vsdstdcelldesign
cd vsdstdcelldesign
cp /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech
ls

magic -T sky130A.tech sky130_lik_inv.mag &
```
![Screenshot from 2024-11-14 05-02-51](https://github.com/user-attachments/assets/b83caeb8-882b-4e29-8825-f5c2f1bbfc34)

**2. Load the custom inverter layout in magic and explore.**

![Screenshot from 2024-11-14 05-03-28](https://github.com/user-attachments/assets/976acae1-e48e-4577-b534-d817f0605f79)

NMOS and PMOS identified
![Screenshot from 2024-11-14 05-05-52](https://github.com/user-attachments/assets/55ec3264-33a4-471f-bf91-f624ef9ef916)
![Screenshot from 2024-11-14 05-06-08](https://github.com/user-attachments/assets/b31a9ef9-a9dc-496a-b5f1-950ed258fc20)

Output Y connectivity to PMOS and NMOS drain verified
![Screenshot from 2024-11-14 05-06-24](https://github.com/user-attachments/assets/c5701d03-14a2-48f0-9ec4-6bbfaadb6f18)

PMOS source connectivity to VDD (here VPWR) verified
![Screenshot from 2024-11-14 05-07-16](https://github.com/user-attachments/assets/b42472ce-d1cd-4044-87c1-fd0d6836de63)

NMOS source connectivity to VSS (here VGND) verified
![Screenshot from 2024-11-14 05-07-33](https://github.com/user-attachments/assets/de931919-e691-42a8-b8a3-5d78760de161)


**3. Spice extraction of inverter in magic.**

Commands for spice extraction of the custom inverter layout to be used in tkcon window of magic
```
pwd
extract all
ext2spice cthresh 0 rthresh 0
ext2spice
```
![Screenshot from 2024-11-14 05-09-42](https://github.com/user-attachments/assets/b6a9e127-b48e-4d65-b7c3-55706308b774)

Screenshot of created spice file
![Screenshot from 2024-11-14 05-16-09](https://github.com/user-attachments/assets/8bec3c54-d7dd-4f91-8ca0-30aeda845888)

**4. Editing the spice model file for analysis through simulation.**
Edited spice file ready for ngspice simulation
![Screenshot from 2024-11-14 05-16-33](https://github.com/user-attachments/assets/a0ce23f9-9e2b-42f5-8b52-c43834f638df)

**5. Post-layout ngspice simulations.**

```
cd
cd Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign
ngspice sky130_lik_inv.spice
plot y vs time a
```
![Screenshot from 2024-11-14 05-52-21](https://github.com/user-attachments/assets/ffc4a060-325b-40c0-bb5c-d2f55e5079b5)
![Screenshot from 2024-11-14 05-52-28](https://github.com/user-attachments/assets/47bb6add-c34f-48c0-b6aa-8c3ac00be324)

- The **rise transition time** is calculated as the time it takes for the output to rise from 20% to 80% of its final value.
- Rise Transition Time = Time taken for output to rise to 80% - Time taken for output to rise to 20%
- **20% of output** = 660 mV
- **80% of output** = 2.64 V
![Screenshot from 2024-11-14 05-53-37](https://github.com/user-attachments/assets/aa084084-32bd-4e9e-8e53-12b8ee4a123e)
![Screenshot from 2024-11-14 05-54-10](https://github.com/user-attachments/assets/0a689640-5800-4547-b83a-36d4dbb07768)
![Screenshot from 2024-11-14 05-54-23](https://github.com/user-attachments/assets/3f7c4168-ef86-4d38-aefd-162fa0b4f8ce)

Rise Transition Time = Time taken for output to rise to 80% - Time taken for output to rise to 20%

$$
\text{Rise transition time} = \text{2.24699} - \text{2.18243} = \text{0.06456} \ \text{ns} = \text{64.56} \ \text{ps}
$$

- The **fall transition time** is calculated as the time it takes for the output to fall from 80% to 20% of its final value.
- Rise Transition Time = Time taken for output to rise to 80% - Time taken for output to rise to 20%
- **20% of output** = 660 mV
- **80% of output** = 2.64 V
![Screenshot from 2024-11-14 05-55-34](https://github.com/user-attachments/assets/afb074e6-3ae9-44d5-8542-1215330fc4b7)
![Screenshot from 2024-11-14 05-55-59](https://github.com/user-attachments/assets/f0e3f89a-de1e-4bdf-9614-8a55cb61cab3)
![Screenshot from 2024-11-14 05-56-14](https://github.com/user-attachments/assets/97cf21a9-0881-4f93-ab9a-703131368721)
Rise Transition Time = Time taken for output to rise to 80% - Time taken for output to rise to 20%

$$
\text{Fall transition time} = \text{4.09558} - \text{4.05241} = \text{0.04317} \ \text{ns}= \text{43.17} \ \text{ps}
$$

- The **Rise Cell Delay** = Time taken for output to rise to 50% - Time taken for input to fall to 50%
- **50% of 3.3V** = 1.65 V
![Screenshot from 2024-11-14 05-57-05](https://github.com/user-attachments/assets/72e97e35-54a6-42c5-9c34-32edb84c29ff)
![Screenshot from 2024-11-14 05-57-52](https://github.com/user-attachments/assets/1fa37e2f-f115-4d9c-9092-f6e121438c5a)
![Screenshot from 2024-11-14 05-57-54](https://github.com/user-attachments/assets/f190f340-d011-400e-a4e2-aed853923166)

$$
\text{Rise Cell Delay} = \text{2.21126} - \text{2.14989} = \text{0.06137} \ \text{ns}= \text{61.37} \ \text{ps}
$$


- The **Fall Cell Delay** = Time taken for output to rise to 50% - Time taken for input to rise to 50%
- **50% of 3.3V** = 1.65 V
![Screenshot from 2024-11-14 05-59-15](https://github.com/user-attachments/assets/3b9f9494-7106-4dbf-a5d0-d5d0dc2b159e)
![Screenshot from 2024-11-14 06-00-12](https://github.com/user-attachments/assets/652daf25-edb6-445d-8288-ab1c0226ed0d)

$$
\text{Fall Cell Delay} = \text{6.21126} - \text{6.14966} = \text{0.0616} \ \text{ns}= \text{61.6} \ \text{ps}
$$


**6. Find problem in the DRC section of the old magic tech file for the skywater process and fix them.**

Link to Sky130 Periphery rules: https://skywater-pdk.readthedocs.io/en/main/rules/periphery.html

Commands to download and view the corrupted skywater process magic tech file and associated files to perform drc corrections

```
cd
wget http://opencircuitdesign.com/open_pdks/archive/drc_tests.tgz
tar xfz drc_tests.tgz
cd drc_tests
ls -al
gvim .magicrc
magic -d XR &
```

## Pre-layout timing analysis and importance of good clock tree

**1. Fix up small DRC errors and verify the design is ready to be inserted into our flow.**

Conditions to be verified before moving forward with custom designed cell layout:
- Condition 1: The input and output ports of the standard cell should lie on the intersection of the vertical and horizontal tracks.
- Condition 2: Width of the standard cell should be odd multiples of the horizontal track pitch.
- Condition 3: Height of the standard cell should be even multiples of the vertical track pitch.

```
cd
cd Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign
magic -T sky130A.tech sky130_lik_inv.mag &
```

Screenshot of tracks.info of sky130_fd_sc_hd
![Screenshot from 2024-11-14 23-52-40](https://github.com/user-attachments/assets/62108ee0-7c7a-46ae-99a3-3c986400ec89)

Commands for tkcon window to set grid as tracks of locali layer
```
help grid
grid 0.46um 0.34um 0.23um 0.17um
```

![Screenshot from 2024-11-14 23-54-30](https://github.com/user-attachments/assets/75c72702-deea-4e28-a0e8-69241d3aeca0)

Condition 1 Verified:
![Screenshot from 2024-11-14 23-55-13](https://github.com/user-attachments/assets/5039642e-530f-4ddd-a9b9-5bf3df430814)

Condition 2 Verified:

$$ \text{Horizontal track pitch} = 0.46 \ \text{um} $$

![Screenshot from 2024-11-14 23-56-49](https://github.com/user-attachments/assets/3dcb5b36-14f1-4da8-a62d-1c38916537e1)
$$ \text{Width of standard cell} = 1.37 \ \text{um}  = 0.46 \* 3 $$

Condition 3 Verified:

$$ \text{Vertical track pitch} = 0.34 \ \text{um} $$
![Screenshot from 2024-11-14 23-58-10](https://github.com/user-attachments/assets/24093e76-9b71-48f0-b42b-b0fb82d7ea51)
$$ \text{Hight of standard cell} = 2.71 \ \text{um}  = 0.34 \* 8 $$

**2. Save the finalized layout with custom name and open it.**


```
save sky130_likith_inv.mag
magic -T sky130A.tech sky130_likith_inv.mag &
```

![Screenshot from 2024-11-15 00-00-18](https://github.com/user-attachments/assets/0466b0a1-020a-4b80-be92-ec61a4edf797)

**3. Generate lef from the layout.**

```
lef write
```

![Screenshot from 2024-11-15 00-01-24](https://github.com/user-attachments/assets/d1890865-5b73-4040-acbb-0674f38a15ad)

Screenshot of newly created lef file:
![Screenshot from 2024-11-15 00-02-20](https://github.com/user-attachments/assets/8cee6439-78ee-4c8b-b439-dab16a2ff110)
![Screenshot from 2024-11-15 00-02-24](https://github.com/user-attachments/assets/91e4d11d-6a07-4bdc-8315-bf86377ce979)


**4. Copy the newly generated lef and associated required lib files to 'picorv32a' design 'src' directory.**

Commands to copy necessary files to 'picorv32a' design 'src' directory:
```
cp sky130_likith_inv.lef ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/
ls ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/
cp libs/sky130_fd_sc_hd__* ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/
ls ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/
```
![Screenshot from 2024-11-15 00-06-54](https://github.com/user-attachments/assets/c20f6e6b-b986-49a3-ad71-2a0d22291ca9)


**5. Edit 'config.tcl' to change lib file and add the new extra lef into the openlane flow.**
Commands to be added to config.tcl to include our custom cell in the openlane flow:
```
set ::env(LIB_SYNTH) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"
set ::env(LIB_FASTEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib"
set ::env(LIB_SLOWEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib"
set ::env(LIB_TYPICAL) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"

set ::env(EXTRA_LEFS) [glob $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/src/*.lef]
```
Edited config.tcl to include the added lef and change library to ones we added in src directory
![Screenshot from 2024-11-15 00-19-26](https://github.com/user-attachments/assets/47fc7ff4-26f1-44b8-a8a0-aa54001f0f68)


**6. Run openlane flow synthesis with newly inserted custom inverter cell.**

Commands to invoke the OpenLANE flow include new lef and perform synthesis:
```
cd
cd Desktop/work/tools/openlane_working_dir/openlane
docker
./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
run_synthesis
```
![Screenshot from 2024-11-15 00-21-51](https://github.com/user-attachments/assets/eca3dc4d-9820-401f-a061-f3cab4847041)
![Screenshot from 2024-11-15 00-22-48](https://github.com/user-attachments/assets/a384c213-5e9d-47e5-9082-4af83e3ccc3f)
![Screenshot from 2024-11-15 00-24-23](https://github.com/user-attachments/assets/45689dd5-dc77-47f4-b5e7-5a2ef2b031fe)
![Screenshot from 2024-11-15 00-32-14](https://github.com/user-attachments/assets/48ea601e-b27d-47b1-9684-ea7750e4f952)


**7. Remove/reduce the newly introduced violations with the introduction of custom inverter cell by modifying design parameters.**
![Screenshot from 2024-11-15 00-24-23](https://github.com/user-attachments/assets/de610a37-fb3f-4058-b8bb-87ee378ee80c)
![Screenshot from 2024-11-15 00-32-14](https://github.com/user-attachments/assets/15bc733f-6544-482d-a3b4-6146a0a4dc45)


```
prep -design picorv32a -tag 24-03_10-03 -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
echo $::env(SYNTH_STRATEGY)
set ::env(SYNTH_STRATEGY) "DELAY 3"
echo $::env(SYNTH_BUFFERING)
echo $::env(SYNTH_SIZING)
set ::env(SYNTH_SIZING) 1
echo $::env(SYNTH_DRIVING_CELL)
run_synthesis
```
![Screenshot from 2024-11-15 00-43-21](https://github.com/user-attachments/assets/f14b0c05-247f-4207-a324-b75154d92d50)


![Screenshot from 2024-11-15 00-33-46](https://github.com/user-attachments/assets/4f6f959a-1231-4367-b010-20d734e89d58)
![Screenshot from 2024-11-15 00-36-07](https://github.com/user-attachments/assets/b7fb3a20-651a-4736-9360-885b19678e34)

**8. Once synthesis has accepted our custom inverter we can now run floorplan and placement and verify the cell is accepted in PnR flow.**

```
run_floorplan
```
![Screenshot from 2024-11-15 00-44-09](https://github.com/user-attachments/assets/9eb63335-1d8d-4aed-9564-47da0c2c1eee)
![Screenshot from 2024-11-15 00-45-29](https://github.com/user-attachments/assets/08c6be1d-4183-482a-8bed-a708ec00a336)

Since we are facing unexpected un-explainable error while using run_floorplan command, we can instead use the following set of commands available based on information from `Desktop/work/tools/openlane_working_dir/openlane/scripts/tcl_commands/floorplan.tcl` and also based on Floorplan Commands section in `Desktop/work/tools/openlane_working_dir/openlane/docs/source/OpenLANE_commands.md`

```
# Follwing commands are alltogather sourced in "run_floorplan" command
init_floorplan
place_io
tap_decap_or
```
![Screenshot from 2024-11-15 00-46-00](https://github.com/user-attachments/assets/7ee22c5f-b54b-40c2-8c31-42761d26ac5d)
![Screenshot from 2024-11-15 00-46-16](https://github.com/user-attachments/assets/a9f6c341-f979-4d66-ab25-3cc424b9267a)

```
run_placement
```

![Screenshot from 2024-11-15 00-46-34](https://github.com/user-attachments/assets/aff99f75-9a1a-4885-bb27-2ecf6b04df9a)
![Screenshot from 2024-11-15 00-51-38](https://github.com/user-attachments/assets/1168a7b7-1b65-4e4c-947f-f5abd3a142b1)

```
cd
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_18-51/results/placement/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
```
Screenshot of placement def in magic:
![Screenshot from 2024-11-15 00-54-57](https://github.com/user-attachments/assets/539e3dfa-905b-406e-93fa-946834df5490)

command to find custom inv:
```
getcell sky130_likith_inv
```

![Screenshot from 2024-11-15 01-13-43](https://github.com/user-attachments/assets/5a25f2ef-e58e-491f-9d5c-b1f0c22c0634)

Screenshot of custom inverter inserted in placement def with proper abutment:
![Screenshot from 2024-11-15 01-36-01](https://github.com/user-attachments/assets/63e4b534-cb63-4c70-9641-a6ef9558b581)

Command for tkcon window to view internal layers of cells:
```
# Command to view internal connectivity layers
expand
```

![Screenshot from 2024-11-15 01-38-27](https://github.com/user-attachments/assets/323f139b-b58d-4337-a9ee-980c4a64dc3f)


**9. Do Post-Synthesis timing analysis with OpenSTA tool.**

```
cd Desktop/work/tools/openlane_working_dir/openlane
docker

./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_SIZING) 1
run_synthesis
```

![Screenshot from 2024-11-15 02-30-50](https://github.com/user-attachments/assets/d829a8f8-c582-4ddf-965a-2cb9f3e4a691)

Newly created `pre_sta.conf` for STA analysis in `openlane` directory

![Screenshot from 2024-11-15 02-43-43](https://github.com/user-attachments/assets/ae8ee908-19c1-4e18-b43e-86a516727f65)

Newly created `my_base.sdc` for STA analysis in `openlane/designs/picorv32a/src` directory based on the file `openlane/scripts/base.sdc`

![Screenshot from 2024-11-15 02-44-11](https://github.com/user-attachments/assets/be28996e-ef5f-4f9d-be07-d5f3ace888af)

```
cd
cd Desktop/work/tools/openlane_working_dir/openlane
sta pre_sta.conf
```

![Screenshot from 2024-11-15 02-45-19](https://github.com/user-attachments/assets/f241b998-ab2d-4fa7-9efc-23c34b43d9c1)
![Screenshot from 2024-11-15 02-45-34](https://github.com/user-attachments/assets/9c6a41bb-2b62-4657-8275-50658500bd3c)
![Screenshot from 2024-11-15 02-45-43](https://github.com/user-attachments/assets/46cf2f5f-d231-4a07-b92e-10a2abb3fcee)

Since more fanout is causing more delay we can add parameter to reduce fanout and do synthesis again
Commands to include new lef and perform synthesis

```
prep -design picorv32a -tag 14-11_18-51 -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_SIZING) 1
set ::env(SYNTH_MAX_FANOUT) 4
echo $::env(SYNTH_DRIVING_CELL)
run_synthesis
```

![Screenshot from 2024-11-15 02-54-54](https://github.com/user-attachments/assets/d88d1dd7-9f49-49ba-a247-9435cd22b033)
![Screenshot from 2024-11-15 02-56-31](https://github.com/user-attachments/assets/a7dee7b4-2465-403e-ab3e-6329f740e8da)

```
cd
cd Desktop/work/tools/openlane_working_dir/openlane
sta pre_sta.conf
```

![Screenshot from 2024-11-15 02-57-25](https://github.com/user-attachments/assets/6406b07b-5039-4fa7-b1ee-9df656b6ff72)
![Screenshot from 2024-11-15 02-57-40](https://github.com/user-attachments/assets/74cd1d9d-c334-4297-b247-34752f1acd12)
![Screenshot from 2024-11-15 02-57-45](https://github.com/user-attachments/assets/dddf7764-0499-4e87-b124-6ca42a6085ec)

**10. Make timing ECO fixes to remove all violations.**
OR gate of drive strength 2 is driving 4 fanouts

![Screenshot from 2024-11-15 02-59-05](https://github.com/user-attachments/assets/fac45823-3a35-4e55-81b8-2c0f9d19e1b5)

Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4
```
report_net -connections _11672_
help replace_cell
replace_cell _14510_ sky130_fd_sc_hd__or3_4
report_checks -fields {net cap slew input_pins} -digits 4
```

Result - Slack Reduced
![Screenshot from 2024-11-15 03-01-46](https://github.com/user-attachments/assets/569179c3-a6b7-4970-a717-eb76f74fedf5)
![Screenshot from 2024-11-15 03-02-07](https://github.com/user-attachments/assets/042959ad-9dd4-4bfb-a8ea-839fe6534f50)
![Screenshot from 2024-11-15 03-02-22](https://github.com/user-attachments/assets/8014a8a9-5b7b-4343-bf3d-b12e2e836faa)

OR gate of drive strength 2 is driving 4 fanouts
![Screenshot from 2024-11-15 03-02-59](https://github.com/user-attachments/assets/cf9d055a-0cb5-46db-85d2-905808c35eab)
Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4:
```
report_net -connections _11675_
replace_cell _14514_ sky130_fd_sc_hd__or3_4
report_checks -fields {net cap slew input_pins} -digits 4
```
Result - Slack Reduced:
![Screenshot from 2024-11-15 03-03-55](https://github.com/user-attachments/assets/1b99bd7b-dba2-475a-8daf-bd8395d764f1)
![Screenshot from 2024-11-15 03-04-05](https://github.com/user-attachments/assets/d796da89-e55f-418b-a3ca-a8f462046ebf)
![Screenshot from 2024-11-15 03-04-09](https://github.com/user-attachments/assets/03091223-53d2-4234-a656-db01ebe25012)

OR gate of drive strength 2 driving OA gate has more delay
![Screenshot from 2024-11-15 03-05-27](https://github.com/user-attachments/assets/96317130-6d9e-4b26-b5d9-bc1a72d8f34f)
Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4:
```
report_net -connections _11643_
replace_cell _14481_ sky130_fd_sc_hd__or4_4
report_checks -fields {net cap slew input_pins} -digits 4
```
Result - Slack Reduced:
![Screenshot from 2024-11-15 03-06-22](https://github.com/user-attachments/assets/ed77da0f-935c-4303-8eb4-981c8afd16a1)
![Screenshot from 2024-11-15 03-06-32](https://github.com/user-attachments/assets/8435333c-4bb7-4df4-9812-f3cdce74b98e)

OR gate of drive strength 2 driving OA gate has more delay
![Screenshot from 2024-11-15 03-06-56](https://github.com/user-attachments/assets/526473e5-f09c-4200-9fdd-2e7ceceb3a66)
Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4
```
report_net -connections _11668_
replace_cell _14506_ sky130_fd_sc_hd__or4_4
report_checks -fields {net cap slew input_pins} -digits 4
```
Result - Slack Reduced:
![Screenshot from 2024-11-15 03-07-40](https://github.com/user-attachments/assets/e4a2926a-07f0-4c6d-98da-2fd9cd3e65e2)
![Screenshot from 2024-11-15 03-07-43](https://github.com/user-attachments/assets/8fbc6bb2-0b6c-48db-9c99-77746ddbbf47)

Commands to verify instance _14506_ is replaced with sky130_fd_sc_hd__or4_4
```
report_checks -from _29043_ -to _30440_ -through _14506_
```
Screenshot of replaced instance:
![Screenshot from 2024-11-15 03-08-13](https://github.com/user-attachments/assets/6231ceb0-f405-45ca-8ae2-0fd21c5bceb5)
We started ECO fixes at wns -23.9000 and now we stand at wns -22.6173 we reduced around 1.2827 ns of violation


**11. Replace the old netlist with the new netlist generated after timing ECO fix and implement the floorplan, placement and cts.**

Now to insert this updated netlist to PnR flow and we can use `write_verilog` and overwrite the synthesis netlist but before that we are going to make a copy of the old old netlist
Commands to make copy of netlist:
```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_18-51/results/synthesis/
ls
cp picorv32a.synthesis.v picorv32a.synthesis_old.v
ls
```
![Screenshot from 2024-11-15 03-09-54](https://github.com/user-attachments/assets/22156b59-3f00-4c47-864f-ac98ade4cefb)

Commands to write verilog:
```
help write_verilog
write_verilog /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_18-51/results/synthesis/picorv32a.synthesis.v
exit
```
![Screenshot from 2024-11-15 03-14-31](https://github.com/user-attachments/assets/99e6a7de-5822-47e5-b735-80b8093d48c5)
Verified that the netlist is overwritten by checking that instance `_14506_` is replaced with `sky130_fd_sc_hd__or4_4`
![Screenshot from 2024-11-15 03-18-36](https://github.com/user-attachments/assets/57d871ff-ab7a-4e45-9ed0-ac8ffab904c0)

Since we confirmed that netlist is replaced and will be loaded in PnR but since we want to follow up on the earlier 0 violation design we are continuing with the clean design to further stages
Commands load the design and run necessary stages
```
prep -design picorv32a -tag 14-11_18-51 -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_STRATEGY) "DELAY 3"
set ::env(SYNTH_SIZING) 1
run_synthesis
init_floorplan
place_io
tap_decap_or
run_placement
unset ::env(LIB_CTS)
run_cts
```
![Screenshot from 2024-11-15 03-22-39](https://github.com/user-attachments/assets/768d7120-bffc-4239-8029-b77347c9069b)
![Screenshot from 2024-11-15 03-22-56](https://github.com/user-attachments/assets/d57e347c-15d3-41e8-a6d9-a35bf6130c4b)
![Screenshot from 2024-11-15 03-24-54](https://github.com/user-attachments/assets/63d6b257-bc1c-49b5-b819-8d1979be63af)
![Screenshot from 2024-11-15 03-25-41](https://github.com/user-attachments/assets/de4415e7-186e-498c-aee5-9a0160a45df3)
![Screenshot from 2024-11-15 03-27-22](https://github.com/user-attachments/assets/b5bd8ddf-5976-4177-bdca-448f3c39bb33)
![Screenshot from 2024-11-15 03-31-15](https://github.com/user-attachments/assets/a9ac8d4b-6a0c-4b22-891d-8ba1b9801053)


**12. Post-CTS OpenROAD timing analysis.**

Commands to be run in OpenLANE flow to do OpenROAD timing analysis with integrated OpenSTA in OpenROAD:
```
openroad
read_lef /openLANE_flow/designs/picorv32a/runs/14-11_18-51/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/14-11_18-51/results/cts/picorv32a.cts.def
write_db pico_cts.db
read_db pico_cts.db
read_verilog /openLANE_flow/designs/picorv32a/runs/14-11_18-51/results/synthesis/picorv32a.synthesis_cts.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
help report_checks
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4
exit
```
![Screenshot from 2024-11-15 03-32-57](https://github.com/user-attachments/assets/eaa8b7fa-85d9-4efe-b284-81dd269ae6ec)
![Screenshot from 2024-11-15 03-33-03](https://github.com/user-attachments/assets/bd03a183-e3ec-44b4-a9ff-a12634f2d1e2)


**13. Explore post-CTS OpenROAD timing analysis by removing 'sky130_fd_sc_hd__clkbuf_1' cell from clock buffer list variable 'CTS_CLK_BUFFER_LIST'.**

Commands to be run in OpenLANE flow to do OpenROAD timing analysis after changing CTS_CLK_BUFFER_LIST
```
echo $::env(CTS_CLK_BUFFER_LIST)
set ::env(CTS_CLK_BUFFER_LIST) [lreplace $::env(CTS_CLK_BUFFER_LIST) 0 0]
echo $::env(CTS_CLK_BUFFER_LIST)
echo $::env(CURRENT_DEF)
set ::env(CURRENT_DEF) /openLANE_flow/designs/picorv32a/runs/14-11_18-51/results/placement/picorv32a.placement.def
run_cts
echo $::env(CTS_CLK_BUFFER_LIST)
openroad
read_lef /openLANE_flow/designs/picorv32a/runs/14-11_18-51/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/14-11_18-51/results/cts/picorv32a.cts.def
write_db pico_cts1.db
read_db pico_cts.db
read_verilog /openLANE_flow/designs/picorv32a/runs/14-11_18-51/results/synthesis/picorv32a.synthesis_cts.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4
report_clock_skew -hold
report_clock_skew -setup
exit
echo $::env(CTS_CLK_BUFFER_LIST)
set ::env(CTS_CLK_BUFFER_LIST) [linsert $::env(CTS_CLK_BUFFER_LIST) 0 sky130_fd_sc_hd__clkbuf_1]
echo $::env(CTS_CLK_BUFFER_LIST)
```
![Screenshot from 2024-11-15 03-36-30](https://github.com/user-attachments/assets/85b30895-1e9c-4e1a-9e06-212324a39d25)
![Screenshot from 2024-11-15 03-36-52](https://github.com/user-attachments/assets/9948cf8f-504c-462e-a893-4a9a20e1d356)
![Screenshot from 2024-11-15 03-37-05](https://github.com/user-attachments/assets/a4852478-0366-441d-b988-ae36c2965c06)
![Screenshot from 2024-11-15 03-37-46](https://github.com/user-attachments/assets/fe6e2a9e-227e-4b12-a6f5-82ed525d78e0)


## Final steps for RTL2GDS using tritonRoute and openSTA
**1. Perform generation of Power Distribution Network (PDN) and explore the PDN layout.**
Commands to perform all necessary stages up until now:
```
cd Desktop/work/tools/openlane_working_dir/openlane
docker

./flow.tcl -interactive
package require openlane 0.9
prep -design picorv32a
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
set ::env(SYNTH_STRATEGY) "DELAY 3"
set ::env(SYNTH_SIZING) 1
run_synthesis
init_floorplan
place_io
tap_decap_or
run_placement
unset ::env(LIB_CTS)
run_cts
gen_pdn
```
Screenshots of power distribution network run
![Screenshot from 2024-11-15 07-00-36](https://github.com/user-attachments/assets/0684bf85-aecf-4c88-9c94-b1e39a107c0b)
![Screenshot from 2024-11-15 07-01-01](https://github.com/user-attachments/assets/418b5c95-ff83-48ce-8e1c-d051a0c4e342)

Commands to load PDN def in magic in another terminal
```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_18-51/tmp/floorplan/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read 14-pdn.def &
```
![Screenshot from 2024-11-15 05-53-16](https://github.com/user-attachments/assets/ec1bd2db-8a5d-4fc2-ada4-7d2bcb9f1547)
![Screenshot from 2024-11-15 05-54-27](https://github.com/user-attachments/assets/e6024ce8-7ff1-4bc9-84db-6f65b7a18700)
![Screenshot from 2024-11-15 05-55-48](https://github.com/user-attachments/assets/31c232eb-7835-4be2-8f1e-9d39cf451659)



**2. Perfrom detailed routing using TritonRoute**.
Command to perform routing
```
echo $::env(CURRENT_DEF)
echo $::env(ROUTING_STRATEGY)
run_routing
```
![Screenshot from 2024-11-15 07-26-42](https://github.com/user-attachments/assets/7b662a51-cd3a-472e-8df5-ec6425a3e543)

Commands to load routed def in magic in another terminal
```
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/15-11_01-22/results/routing/
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.def &
```
Screenshots of routed def
![Screenshot from 2024-11-15 07-23-34](https://github.com/user-attachments/assets/dad70ee8-f84a-4b31-9c05-8cc34737b639)
![Screenshot from 2024-11-15 07-25-06](https://github.com/user-attachments/assets/9b5c038e-b4d8-4291-8197-e72fd50e8efe)
![Screenshot from 2024-11-15 07-25-35](https://github.com/user-attachments/assets/738d5422-6e04-4412-9b2b-e858b626886d)

![Screenshot from 2024-11-15 07-56-16](https://github.com/user-attachments/assets/f49b9968-2ce7-4343-81dd-2d81f4bd0407)

**3. Post-Route parasitic extraction using SPEF extractor.**
Commands for SPEF extraction using external tool
```
cd Desktop/work/tools/SPEF_EXTRACTOR
python3 main.py /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_18-51/tmp/merged.lef /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_18-51/results/routing/picorv32a.def
```
**4. Post-Route OpenSTA timing analysis with the extracted parasitics of the route.**
Commands to be run in OpenLANE flow to do OpenROAD timing analysis with integrated OpenSTA in OpenROAD
```
openroad
read_lef /openLANE_flow/designs/picorv32a/runs/15-11_01-22/tmp/merged.lef
read_def /openLANE_flow/designs/picorv32a/runs/15-11_01-22/results/routing/picorv32a.def
write_db pico_route.db
read_db pico_route.db
read_verilog /openLANE_flow/designs/picorv32a/runs/15-11_01-22/results/synthesis/picorv32a.synthesis_preroute.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc
set_propagated_clock [all_clocks]
read_spef /openLANE_flow/designs/picorv32a/runs/15-11_01-22/results/routing/picorv32a.spef
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4
exit
```
![Screenshot from 2024-11-15 07-47-12](https://github.com/user-attachments/assets/96bb69d2-a542-452e-bfa3-1257ba27dc1e)
![image](https://github.com/user-attachments/assets/2a315fdc-cd1c-47d8-84ff-728cca089fea)

</details>
