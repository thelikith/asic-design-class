<details>
  <summary>LAB 1:  Writing a C program and comparing the outputs when compiling the code with both GCC and the RISC-V compiler</summary>
   

   **Let's write a simple C program to count numbers from 1 to N and compile it using GCC.**

Code to count numbers from 1 to 30:

![Screenshot 2024-07-17 134436](https://github.com/user-attachments/assets/a684f778-bf97-4889-a4ff-e30908945d56)

Output:

![Screenshot from 2024-07-17 14-54-39](https://github.com/user-attachments/assets/918f5dba-6b4c-448f-9fb3-0d8d7de4a4da)

**Now let's compile the same code using RISC-V**

![Screenshot from 2024-07-17 14-54-45](https://github.com/user-attachments/assets/63a713bf-d308-4f0a-aa7b-80d3b56fb300)

We open the object dumpfile using the command
```
riscv64-unknown-elf-objdump -d -sum1toN.o | less
```

![Screenshot from 2024-07-17 14-54-55](https://github.com/user-attachments/assets/8f09fa57-9167-4c6c-8f94-49de255c374a)

</details>



***



<details>
  <summary>LAB 2: Running the object file generated by the RISC-V compiler in the Spike Simulator, and performing debugging with the Spike Debugger</summary>
     
  In our previous lab, we compiled our C code using both gcc and a RISC-V compiler.
   
  ![Screenshot from 2024-07-20 14-17-33](https://github.com/user-attachments/assets/290c7134-0096-4802-84de-a00084905d32)

![Screenshot from 2024-07-20 14-20-11](https://github.com/user-attachments/assets/216bf957-e569-47a0-b448-0eeafaa4ba14)


Now, we will examine the output file generated by compiling the C code with the RISC-V compiler and debug the instructions.

Steps followed
1) Inspect the output generated by compiling the code with the gcc compiler, located in the file 'a.out'
2) Inspect the output generated by compiling the code with the RISC-V compiler, located in the file 'sum1toN.o'. and Check whether the outputs are the same or not
   
   ![Screenshot from 2024-07-20 14-18-57](https://github.com/user-attachments/assets/b971e17f-7aa8-4c52-9c0b-a1433c3e24a8)
   
4) Now we start debugging using the spike debugger
5) We will allow the Spike debugger to run until the main function, specifically until the **100b0** instruction. After that, we will manually continue debugging and inspect the **a0** register before and after the execution. We observe that the instruction **lui a0, 0x21** updates the a0 register from **0x0000000000000001** to **0x0000000000021000**
   
   ![Screenshot from 2024-07-20 15-10-29](https://github.com/user-attachments/assets/6928d9f4-c50e-4c29-a4df-28be34fb50b2)

6) Next, we will manually debug the next instruction  i.e., **addi sp, sp, -16**. This instruction decrements the stack pointer (sp) by 16. Before executing this instruction, the sp register held the value **0x0000003ffffffb50**, which is then updated to **0x0000003ffffffb40**

      ![Screenshot 2024-07-20 235518](https://github.com/user-attachments/assets/5efd476a-c03c-46d7-a20d-bd528eabd4f8)

The output appears at register 100b8, and it remains the same regardless of whether the code is executed using the gcc or riscv compilers.

### Now we will see the difference in the switches O1 and Ofast
![Screenshot from 2024-08-12 21-08-32](https://github.com/user-attachments/assets/4da34596-2b81-47bd-8cec-640ced76a240)

**assembly code with O1 switch:**
![Screenshot from 2024-08-12 21-04-25](https://github.com/user-attachments/assets/184e2ba2-683e-4e9e-8855-6d6dcbedf306)

**assembly code with Ofast switch:**
![Screenshot from 2024-08-12 21-06-22](https://github.com/user-attachments/assets/48583f24-095d-42f7-bee7-64d438ede310)

+ Number of instructions when compiled with O1 switch = 14
+ Number of instructions when compiled with Ofast switch = 11
+ We can observe that using the **-Ofast** optimization switch results in fewer assembly instructions compared to the **-O1** switch.

</details>



***



<details>
  <summary>LAB 3: 32-bit RISC-V Instruction Formats: Encoding, Simulation, and Waveform Analysis </summary>

  ## Task 1: RISC-V Instruction Formats and Hexadecimal Encoding of Specific Instructions
  ### Base Instruction Formats

  RISC-V has six core instruction formats: R, I, S, B, U, and J. These are all fixed 32 bits in length. Here is a brief description of each format:

  There are four core instruction formats (R/I/S/U), and there are a further two variants of the instruction formats (B/J) based on the handling of immediates.
  1. **R-Type (Register)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | funct7[31:25]
     + Used for register-register arithmetic and logical operations.
       ![Screenshot 2024-07-24 191623](https://github.com/user-attachments/assets/0bbb9695-b331-46e2-a75a-92a074344659)

  2. **I-Type (Immediate)**
     + Format: opcode[6:0] | rd[11:7] | funct3[14:12] | rs1[19:15] | imm[31:20]
     + Used for immediate arithmetic, logical operations, and load instructions.
       ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)

  3. **S-Type (Store)**
     + Format: opcode[6:0] | imm[11:7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for store instructions.
       ![Screenshot 2024-07-24 191625](https://github.com/user-attachments/assets/446beff5-399d-4426-b868-0d9c6d2ef271)

  4. **U-Type (Upper Immediate)**
     + Format: opcode[6:0] | rd[11:7] | imm[31:12]
     + Used for instructions that operate with a 20-bit upper immediate, such as LUI (Load Upper Immediate).
        ![Screenshot 2024-07-24 191626](https://github.com/user-attachments/assets/60c0073d-2e33-4fbd-a54b-01a606aeb353)

  5. **B-Type (Branch)**
     + Format: opcode[6:0] | imm[11][7] | funct3[14:12] | rs1[19:15] | rs2[24:20] | imm[31:25]
     + Used for conditional branch instructions.
       ![Screenshot 2024-07-24 191847](https://github.com/user-attachments/assets/33c0c62f-3fe2-48bd-a1f5-18db951807cf)

  6. **J-Type (Jump)**
     + Format: opcode[6:0] | rd[11:7] | imm[19:12] | imm[31:20]
     + Used for jump instructions, such as JAL (Jump And Link).
       ![Screenshot 2024-07-24 191848](https://github.com/user-attachments/assets/7b2e93a1-1fc8-447f-95ed-1d34b82e8625)
       
RISC-V instruction types and the corresponding 32-bit instruction codes for the provided instructions:

1. ADD r9, r10, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0000000
   + rs1: 01010
   + rs2: 01011
   + rd: 01001
   + Instruction: 0000000 01011 01010 000 01001 0110011
     + 0x00B504B3
     
2. SUB r11, r9, r10
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 000
   + funct7: 0100000
   + rs1: 01001
   + rs2: 01010
   + rd: 01011
   + Instruction: 0100000	01010	01001	000	01011	0110011
     + 0x40A485B3
     
3. AND r10, r9, r11
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 111
   + funct7: 0000000
   + rs1: 01001
   + rs2: 01011
   + rd: 01010
   + Instruction: 0000000	01011	01001	111	01010	0110011
     + 0x00B4F533
       
4. OR r8, r10, r5
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 110
   + funct7: 0000000
   + rs1: 01010
   + rs2: 00101
   + rd: 01000
   + Instruction: 0000000	00101	01010	110	01000	0110011
     + 0x00556433
     
5. XOR r8, r9, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 100
   + funct7: 0000000
   + rs1: 01001
   + rs2: 00100
   + rd: 01000
   + Instruction: 0000000	00100	01001	100	01000	0110011
     + 0x0044C433
     
6. SLT r0, r1, r4
   + Type: R-Type
   + Opcode: 0110011
   + funct3: 010
   + funct7: 0000000
   + rs1: 00001
   + rs2: 00100
   + rd: 00000
   + Instruction: 0000000	00100	00001	010	00000	0110011
     + 0x0040A033
     
7. ADDI r2, r2, 5
   + Type: I-Type
   + Opcode: 0010011
   + funct3: 000
   + Immediate: 000000000101
   + rs1: 00010
   + rd: 00010
   + Instruction: 000000000101	00010	000	00010	0010011
     + 0x00510113
     
8. SW r2, r0, 4
   + Type: S-Type
   + Opcode: 0100011
   + funct3: 010
   + Immediate: 000000000100
   + imm[11:5]: 0000000
   + imm[4:0]: 00100
   + rs1: 00000
   + rd: 00010
   + Instruction: 0000000	00010	00000	010	00100	0100011
     + 0x00202223
     
9. SRL r6, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 101
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00110
    + Instruction: 0000000	00001	00001	101	00110	0110011
      + 0x0010D333
      
10. BNE r0, r0, 20
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 001
    + Immediate: 000000010100
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1010
    + Instruction: 0 000000	00000	00000	001	1010 0	1100011
      + 0x00001A63
      
11. BEQ r0, r0, 15
    + Type: B-Type
    + Opcode: 1100011
    + funct3: 000
    + Immediate: 000000001111
    + imm[12]: 0
    + imm[11]: 0
    + imm[10:5]: 000000
    + imm[4:1]: 1111
    + Instruction: 0 000000	00000	00000	000	1111 0	1100011
      + 0x00000F63
      
12. LW r3, r1, 2
    + Type: I-Type
    + Opcode: 0000011
    + funct3: 010
    + Immediate: 000000000010
    + rs1: 00001
    + rd: 00011
    + Instruction: 000000000010	00001	010	00011	0000011
      + 0x0020A183
      
13. SLL r5, r1, r1
    + Type: R-Type
    + Opcode: 0110011
    + funct3: 001
    + funct7: 0000000
    + rs1: 00001
    + rs2: 00001
    + rd: 00101
    + Instruction: 0000000	00001	00001	001	00101	0110011
      + 0x001092B3
   
    | Instruction | Format |  Standard ISA Code |
    | :----------: | :------: | :------------------: |
    | ADD r9, r10, r11 | R | 0x00B504B3 |
    | SUB r11, r9, r10 | R | 0x40A485B3 |
    | AND r10, r9, r11 | R | 0x00B4F533 |
    | OR r8, r10, r5 | R | 0x00556433 |
    | XOR r8, r9, r4 | R | 0x0044C433 |
    | SLT r0, r1, r4 | R | 0x0040A033 |
    | ADDI r2, r2, 5 | I | 0x00510113 |
    | SW r2, r0, 4 | S | 0x00202223 |
    | SRL r6, r1, r1 | R | 0x0010D333 |
    | BNE r0, r0, 20 | B | 0x00001A63 |
    | BEQ r0, r0, 15 | B | 0x00000F63 |
    | LW r3, r1, 2 | I | 0x0020A183 |
    | SLL r5, r1, r1 | R | 0x001092B3 |

  ## Task 2: Simulation and Waveform analysis
  ### Steps to perform functional simulational
  1. Create two files in gedit as iiitb_rv32i.v and iiitb_rv32i_tb.v
  2. Copy the code from the reference github repository and paste it in your verilog and testbench files
  3. To run and simulate the verilog code in gtkwave, enter the following commands:
     ![Screenshot from 2024-07-28 18-34-21](https://github.com/user-attachments/assets/16c1874b-3d22-4eb4-b84c-5790071a1bff)

  **Following are the differences between standard RISCV ISA and Hardcoded ISA for the instruction set given in the reference repository:**  

  The standard RISC-V ISA for the given instructions can be generated in a manner similar to the approach we used in Task 1
  
  Hard-coded instructions: These are custom instructions where the bit patterns are manually set by the designer rather than adhering to the standard RISC-V specification. And they are designed for a specific purpose or application. Hence the 32-bits instruction that we generated will not match with the hardcoded ISA.
  
  
  |  **Instructions**  |  **Standard RISCV ISA**  |  **Hardcoded ISA**  |  
  |  :----:  |  :----:  |  :----:  |  
  |  ADD R6, R2, R1  |  32'h00110333  |  32'h02208300  |  
  |  SUB R7, R1, R2  |  32'h402083b3  |  32'h02209380  |  
  |  AND R8, R1, R3  |  32'h0030f433  |  32'h0230a400  |  
  |  OR R9, R2, R5  |  32'h005164b3  |  32'h02513480  |  
  |  XOR R10, R1, R4  |  32'h0040c533  |  32'h0240c500  |  
  |  SLT R1, R2, R4  |  32'h0045a0b3  |  32'h02415580  |  
  |  ADDI R12, R4, 5  |  32'h004120b3  |  32'h00520600  |  
  |  BEQ R0, R0, 15  |  32'h00000f63  |  32'h00f00002  |  
  |  SW R3, R1, 2  |  32'h0030a123  |  32'h00209181  |  
  |  LW R13, R1, 2  |  32'h0020a683  |  32'h00208681  |  
  |  SRL R16, R14, R2  |  32'h0030a123  |  32'h00271803  |
  |  SLL R15, R1, R2  |  32'h002097b3  |  32'h00208783  |  

  ### Analysing output waveforms of above given instructions:

  ```
  ADD R6, R2, R1
  ```
  ![IMG_0010](https://github.com/user-attachments/assets/30cb6411-4c2a-4a2b-9f43-430c505ac4e7)


  ```
  SUB R7, R1, R2
  ```
  ![IMG_0013](https://github.com/user-attachments/assets/aa230620-2c97-4abb-b0a3-96fd3995f3a8)

  
  ```
  AND R8, R1, R3
  ```
  ![IMG_0027](https://github.com/user-attachments/assets/cad8c2be-643e-431e-8579-460a29b6a59c)


  ```
  OR R9, R2, R5
  ```
  ![IMG_0016](https://github.com/user-attachments/assets/88b1edde-9b3d-4271-af0c-dac55c3300dc)


  ```
  XOR R10, R1, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/95486b24-2a92-4d3b-8f18-4c549ee5bf4f)


  ```
  SLT R1, R2, R4
  ```
  ![IMG_0011](https://github.com/user-attachments/assets/13e32a3b-a2e3-4105-9df3-1cf0fe0c60a4)


  ```
  ADDI R12, R4, 5
  ```
  ![IMG_0009](https://github.com/user-attachments/assets/8de296ea-9d55-4dba-9c89-738b470e5d97)


  ```
  BEQ R0, R0, 15
  ```
  ![IMG_0012](https://github.com/user-attachments/assets/a3c34a83-c1e6-4d80-bae5-f187535afc77)


 **5-Stage instruction pipeline**
 ![Screenshot from 2024-07-29 03-34-25](https://github.com/user-attachments/assets/f3e95dc9-f367-4cbb-ad81-0a73c286b899)

</details>


***



<details>
  <summary>LAB 4:  Selecting and Compiling a C Application with GCC and RISC-V GCC compiler</summary>
  
  ## Application Name: Logic Gate Simulator
  ### Overview: Simulates the behavior of basic logic gates (AND, OR, NOT, etc.) with truth tables and custom inputs
  **Logic Gate Simulator** is a C-based application designed to simulate the behavior of basic logic gates, including AND, OR, NOT, XOR, NAND, NOR. The application allows users to input custom values, generate truth tables

  **Code:**
  ```c
#include <stdio.h>

// Function prototypes for logic gates
int AND(int a, int b);
int OR(int a, int b);
int NOT(int a);
int XOR(int a, int b);
int NAND(int a, int b);
int NOR(int a, int b);

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name);

// Function to print the truth table for NOT gate
void print_truth_table_not();

// Main function
int main() {
    int choice;
    
    printf("Logic Gate Simulator\n");
    printf("1. AND Gate\n");
    printf("2. OR Gate\n");
    printf("3. NOT Gate\n");
    printf("4. XOR Gate\n");
    printf("5. NAND Gate\n");
    printf("6. NOR Gate\n");
    printf("Enter your choice (1-6): ");
    scanf("%d", &choice);

    switch(choice) {
        case 1:
            print_truth_table_two_inputs(AND, "AND");
            break;
        case 2:
            print_truth_table_two_inputs(OR, "OR");
            break;
        case 3:
            print_truth_table_not();
            break;
        case 4:
            print_truth_table_two_inputs(XOR, "XOR");
            break;
        case 5:
            print_truth_table_two_inputs(NAND, "NAND");
            break;
        case 6:
            print_truth_table_two_inputs(NOR, "NOR");
            break;
        default:
            printf("Invalid choice!\n");
    }

    return 0;
}

// AND gate function
int AND(int a, int b) {
    return a & b;
}

// OR gate function
int OR(int a, int b) {
    return a | b;
}

// NOT gate function
int NOT(int a) {
    return !a;
}

// XOR gate function
int XOR(int a, int b) {
    return a ^ b;
}

// NAND gate function
int NAND(int a, int b) {
    return !(a & b);
}

// NOR gate function
int NOR(int a, int b) {
    return !(a | b);
}

// Function to print the truth table for two-input gates
void print_truth_table_two_inputs(int (*gate)(int, int), const char *gate_name) {
    printf("\nTruth Table for %s Gate\n", gate_name);
    printf("A B | Output\n");
    printf("------------\n");

    for(int a = 0; a <= 1; a++) {
        for(int b = 0; b <= 1; b++) {
            printf("%d %d |   %d\n", a, b, gate(a, b));
        }
    }
}

// Function to print the truth table for NOT gate
void print_truth_table_not() {
    printf("\nTruth Table for NOT Gate\n");
    printf("A | Output\n");
    printf("---------\n");

    for(int a = 0; a <= 1; a++) {
        printf("%d |   %d\n", a, NOT(a));
    }
}
```

**Compiling the application using the GCC compiler:**

![Screenshot from 2024-08-14 20-17-59](https://github.com/user-attachments/assets/5aa3c864-798a-468e-a0ff-294b7c522f0b)


**Compiling the application using the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-18-56](https://github.com/user-attachments/assets/6264cabc-ee3d-4e84-8906-1fc4b3fb76a3)

**Comparing the output of the application when compiled with the standard GCC compiler versus the RISC-V GCC compiler**

![Screenshot from 2024-08-14 20-19-49](https://github.com/user-attachments/assets/31633f1a-5c3c-480a-97f6-85663384a5d2)


</details>


***


<details>
  <summary>LAB 5: 5 Stage Pipelined RISC-V Processor </summary>
  
**TL-Verilog** is a higher-level version of Verilog used for modeling and designing digital systems in a more abstract way. Instead of focusing on the detailed wiring and gates, TL-Verilog lets you describe how a system behaves without getting into the specifics of its implementation. This abstraction is useful for system-level design and simulation.

**Makerchip** is an online platform where you can design, simulate, and test digital systems using HDLs like TL-Verilog, Verilog, and VHDL. It offers a user-friendly environment for creating and experimenting with digital designs, making it great for learning, teaching, and prototyping. 
  
  <details>
    <summary> Digital Logic with TL-Verilog and Makerchip </summary>
Logic gates are essential parts of digital circuits. They perform basic operations on binary data (0s and 1s) and are key to how computers and other digital devices handle information. There are different types of logic gates, each with a specific function
    
  ![Screenshot (219)](https://github.com/user-attachments/assets/37dc2892-d103-4f6c-9e1c-d6bcde83cfd1)
  ![Screenshot (220)](https://github.com/user-attachments/assets/042668ea-4aea-4698-9850-4742b14bc3a1)
    
  ### Combinational Logic in TL-Verilog and Makerchip
  
  Combinational logic involves creating circuits that process binary inputs to produce binary outputs based on set rules. These circuits operate without memory or feedback, meaning their outputs depend only on the current inputs and not on past states.
  
  **1) Inverter on Makerchip**
     ![Screenshot (209)](https://github.com/user-attachments/assets/73a65273-f58c-47cb-b0cd-08f38ab66bcf)     
  **2) AND gate on Makerchip**
     ![Screenshot (210)](https://github.com/user-attachments/assets/2aef5ed9-377a-43ef-b8c6-f9525a4be4e6)
  **3) OR gate on Makerchip**
     ![Screenshot (212)](https://github.com/user-attachments/assets/afef06d7-b4cd-4ab9-a014-12672f220c2a)
  **4) EXOR gate on Makerchip**
     ![Screenshot (213)](https://github.com/user-attachments/assets/ce40afa4-ddec-4918-bfa8-67600cb20964)
  **5) Vectors on Makerchip**
     ![Screenshot (214)](https://github.com/user-attachments/assets/3c5081a4-eddd-4544-b6c7-3280bf8cd100)
  **6) Mux on Makerchip**
     ![Screenshot (215)](https://github.com/user-attachments/assets/3a3b02c7-be90-41f5-b290-6b03b845eb67)
     ![Screenshot (216)](https://github.com/user-attachments/assets/9b687af5-a899-4641-9be3-7d33632490c0)
  **7) Calculator on Makerchip**
  ```c
\TLV
   $reset = *reset;
   
   $val1[31:0] = $rand1[3:0];
   $val2[31:0] = $rand2[3:0];
   $sum[31:0]  = $val1[31:0] + $val2[31:0];
   $diff[31:0] = $val1[31:0] - $val2[31:0];
   $prod[31:0] = $val1[31:0] * $val2[31:0];
   $quot[31:0] = $val1[31:0] / $val2[31:0];
   
   $out[31:0] = $op[1] ? ($op[0] ? $quot[31:0] : $prod[31:0]) : ($op[0] ? $diff[31:0] : $add[31:0]); 
  ```

  ![Screenshot (218)](https://github.com/user-attachments/assets/d97dcefb-635b-4c5d-91b5-6338297be285)


  ### Sequential Logic in TL-Verilog and Makerchip
  Sequential logic is a type of digital circuit where the output depends on both the current inputs and the circuit's previous states. Unlike combinational logic, which only uses current inputs to produce outputs, sequential logic includes memory elements to keep track of past information and influence the current output.
  
**1) Sequential calculator on Makerchip**
![Screenshot (222)](https://github.com/user-attachments/assets/9d23930c-9b12-4529-8c0f-14c59fd0da43)


  ```c
\TLV
   |calc
      @1
         $clk_lik = *clk;
         $reset = *reset;
         $val1[31:0] = >>1$result[31:0];
         $val2[31:0] = $rand2[3:0];
         $result[31:0] = $reset ? 32'b0 : ($sel[1:0] == 2'b00)
                         ? ($val1[31:0] + $val2[31:0]) : ($sel[1:0] == 2'b01)
                         ? ($val1[31:0] - $val2[31:0]) : ($sel[1:0] == 2'b10)
                         ? ($val1[31:0] * $val2[31:0]) : ($sel[1:0] == 2'b11)
                         ? ($val2[31:0] != 0 ? ($val1[31:0] / $val2[31:0]) : 32'bx) :  32'b0;
 ```

  ![Screenshot (221)](https://github.com/user-attachments/assets/10f9e7de-4be1-4d33-9103-3adacdd45b3c)


  ### Pipelined Logic
  
Pipelining is a key feature in TL-Verilog that simplifies coding and helps reduce bugs compared to SystemVerilog. In TL-Verilog, you can easily implement pipelining with less code. For example, in the provided repo, you can see how pipelining is used to calculate the Pythagorean theorem. In TL-Verilog, you define the pipeline stages using |calc and align them with @1, @2, and so on.



**2-Cycle Calculator in Pipeline**

![Screenshot (226)](https://github.com/user-attachments/assets/d4c28f9f-d80b-4618-99fe-d1c3f7e7626e)


```c
\TLV
   |calc
      @1
         $reset = *reset;
         $clk_lik = *clk;
         $val1[31:0] = >>2$out[31:0];
         $val2[31:0] = $rand2[3:0];
         $op[1:0] = $rand3[1:0];
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         
         $num = $reset ? 0 : >>1$num+1;
      @2   
         $out[31:0] = ($reset|!$num) ? 32'b0 : (($op[1:0]==2'b00) ? $sum :
                                       ($op[1:0]==2'b01) ? $diff :
                                          ($op[1:0]==2'b10) ? $prod : $quot);
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
```
![Screenshot (227)](https://github.com/user-attachments/assets/4ba5d5df-4b1b-4767-aac9-d618c337afca)


  ### Validity
  **1) 2-Cycle Calculator with Validity**
  
  ![Screenshot (233)](https://github.com/user-attachments/assets/eb5d65f4-1688-4bba-b263-9a4078c43be6)

  ```c
\TLV
    |calc
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
      @1
         $val1 [31:0] = >>2$out;
         $val2 [31:0] = $rand2[3:0];
         
         $valid = $reset ? 1'b0 : >>1$valid + 1'b1 ;
         $valid_or_reset = $valid || $reset;
         
      ?$vaild_or_reset
         @1   
            $sum [31:0] = $val1 + $val2;
            $diff[31:0] = $val1 - $val2;
            $prod[31:0] = $val1 * $val2;
            $quot[31:0] = $val1 / $val2;
            
         @2   
            $mem[31:0] = $reset ? 32'b0 :
                         ($op[2:0] == 3'b101) ? $val1 : >>2$mem ;
            
            $out [31:0] = $reset ? 32'b0 :
                          ($op[2:0] == 3'b000) ? $sum :
                          ($op[2:0] == 3'b001) ? $diff :
                          ($op[2:0] == 3'b010) ? $prod :
                          ($op[2:0] == 3'b011) ? $quot :
                          ($op[2:0] == 3'b100) ? >>2$mem : >>2$out ;
  ```
![Screenshot (234)](https://github.com/user-attachments/assets/1b1824fc-60f2-42d6-99fb-ae8fc9a00eae)


  **2) Calculator with single value memory**
  
![Screenshot (236)](https://github.com/user-attachments/assets/4f59abf9-15e6-48b5-b579-4924577dfc63)
```c
\TLV
    |calc
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
      @1
         $val1 [31:0] = >>2$out;
         $val2 [31:0] = $rand2[3:0];
         
         $valid = $reset ? 1'b0 : >>1$valid + 1'b1 ;
         $valid_or_reset = $valid || $reset;
         
      ?$vaild_or_reset
         @1   
            $sum [31:0] = $val1 + $val2;
            $diff[31:0] = $val1 - $val2;
            $prod[31:0] = $val1 * $val2;
            $quot[31:0] = $val1 / $val2;
            
         @2   
            $mem[31:0] = $reset ? 32'b0 :
                         ($op[2:0] == 3'b101) ? $val1 : >>2$mem ;
            
            $out [31:0] = $reset ? 32'b0 :
                          ($op[2:0] == 3'b000) ? $sum :
                          ($op[2:0] == 3'b001) ? $diff :
                          ($op[2:0] == 3'b010) ? $prod :
                          ($op[2:0] == 3'b011) ? $quot :
                          ($op[2:0] == 3'b100) ? >>2$mem : >>2$out ;
```
![Screenshot (237)](https://github.com/user-attachments/assets/9195b7f4-1db3-4afe-ab27-482f80ef35f4)

  </details>

  
  <details>
    <summary> Basic RISC-V CPU micro-architecture </summary>
    
  ### Introduction to Simple RISC-V micro-architecture 
  RISC-V block diagram A block diagram of a RISC-V processor provides a high-level overview of its major components and how they are interconnected. Here's a block diagram of a typical RISC-V processor:

  + **Decoder:** The decoder translates binary instructions into control signals that direct the processor's functional units on how to execute them.
  + **Instruction Memory:** Instruction memory stores and supplies the machine instructions needed by the processor for execution.
  + **ALU (Arithmetic Logic Unit):** The ALU performs arithmetic and logical operations on data, such as addition and comparisons.
  + **ALU Control Unit:** The ALU control unit provides signals to configure the ALU for the specific operation required by the current instruction.
  + **Register File:** The register file contains general-purpose registers that temporarily store data during instruction execution.
  + **Data Memory:** Data memory holds data for read and write operations and is used in load and store instructions.

  ### Fetch and Decode
  
  

  ### RISC-V Control logic

  </details>


  <details>
    <summary> Complete Pipelined RISC-V CPU micro-architecture </summary>
    
  ### RISCV core with Pipeline
  ```c
\m4_TLV_version 1d: tl-x.org
\SV
   // Template code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 10000)           // Store r10 result in dmem
   m4_asm(LW, r17, r0, 10000)           // Load contents of dmem to r17
   m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_lik = *clk;
         
         //PC fetch - branch, jumps and loads introduce 2 cycle bubbles in this pipeline
         $pc[31:0] = >>1$reset ? '0 : (>>3$valid_taken_br ? >>3$br_tgt_pc :
                                       >>3$valid_load     ? >>3$inc_pc[31:0] :
                                       >>3$jal_valid      ? >>3$br_tgt_pc :
                                       >>3$jalr_valid     ? >>3$jalr_tgt_pc :
                                                     (>>1$inc_pc[31:0]));
         // Access instruction memory using PC
         $imem_rd_en = ~ $reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         
         
      @1
         //Getting instruction from IMem
         $instr[31:0] = $imem_rd_data[31:0];
         
         //Increment PC
         $inc_pc[31:0] = $pc[31:0] + 32'h4;
         
         //Decoding I,R,S,U,B,J type of instructions based on opcode [6:0]
         //Only [6:2] is used here because this implementation is for RV64I which does not use [1:0]
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $is_j_instr = $instr[6:2] == 5'b11011;
         
         //Immediate value decode
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}} , $instr[30:20]} :
                      $is_s_instr ? { {21{$instr[31]}} , $instr[30:25] , $instr[11:8] , $instr[7]} :
                      $is_b_instr ? { {20{$instr[31]}} , $instr[7] , $instr[30:25] , $instr[11:8] , 1'b0} :
                      $is_u_instr ? { $instr[31] , $instr[30:12] , { 12{1'b0}} } :
                      $is_j_instr ? { {12{$instr[31]}} , $instr[19:12] , $instr[20] , $instr[30:21] , 1'b0} :
                      >>1$imm[31:0];
         
         //Generate valid signals for each instruction fields
         $rs1_or_funct3_valid    = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rs2_valid              = $is_r_instr || $is_s_instr || $is_b_instr;
         $rd_valid               = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid           = $is_r_instr;
         
         //Decode other fields of instruction - source and destination registers, funct, opcode
         ?$rs1_or_funct3_valid
            $rs1[4:0]    = $instr[19:15];
            $funct3[2:0] = $instr[14:12];
         
         ?$rs2_valid
            $rs2[4:0]    = $instr[24:20];
         
         ?$rd_valid
            $rd[4:0]     = $instr[11:7];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         //Decode instruction in subset of base instruction set based on RISC-V 32I
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         //Branch instructions
         $is_beq   = $dec_bits ==? 11'bx_000_1100011;
         $is_bne   = $dec_bits ==? 11'bx_001_1100011;
         $is_blt   = $dec_bits ==? 11'bx_100_1100011;
         $is_bge   = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu  = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu  = $dec_bits ==? 11'bx_111_1100011;
         
         //Jump instructions
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal   = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr  = $dec_bits ==? 11'bx_000_1100111;
         
         //Arithmetic instructions
         $is_addi  = $dec_bits ==? 11'bx_000_0010011;
         $is_add   = $dec_bits ==  11'b0_000_0110011;
         $is_lui   = $dec_bits ==? 11'bx_xxx_0110111;
         $is_slti  = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori  = $dec_bits ==? 11'bx_100_0010011;
         $is_ori   = $dec_bits ==? 11'bx_110_0010011;
         $is_andi  = $dec_bits ==? 11'bx_111_0010011;
         $is_slli  = $dec_bits ==? 11'b0_001_0010011;
         $is_srli  = $dec_bits ==? 11'b0_101_0010011;
         $is_srai  = $dec_bits ==? 11'b1_101_0010011;
         $is_sub   = $dec_bits ==? 11'b1_000_0110011;
         $is_sll   = $dec_bits ==? 11'b0_001_0110011;
         $is_slt   = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu  = $dec_bits ==? 11'b0_011_0110011;
         $is_xor   = $dec_bits ==? 11'b0_100_0110011;
         $is_srl   = $dec_bits ==? 11'b0_101_0110011;
         $is_sra   = $dec_bits ==? 11'b1_101_0110011;
         $is_or    = $dec_bits ==? 11'b0_110_0110011;
         $is_and   = $dec_bits ==? 11'b0_111_0110011;
         
         //Store instructions
         $is_sb    = $dec_bits ==? 11'bx_000_0100011;
         $is_sh    = $dec_bits ==? 11'bx_001_0100011;
         $is_sw    = $dec_bits ==? 11'bx_010_0100011;
         
         //Load instructions - support only 4 byte load
         $is_load  = $dec_bits ==? 11'bx_xxx_0000011;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         //Get Source register values from reg file
         $rf_rd_en1 = $rs1_or_funct3_valid;
         $rf_rd_en2 = $rs2_valid;
         
         $rf_rd_index1[4:0] = $rs1[4:0];
         $rf_rd_index2[4:0] = $rs2[4:0];
         
         //Register file bypass logic - data forwarding from ALU to resolve RAW dependence
         $src1_value[31:0] = $rs1_bypass ? >>1$result[31:0] : $rf_rd_data1[31:0];
         $src2_value[31:0] = $rs2_bypass ? >>1$result[31:0] : $rf_rd_data2[31:0];
         
         //Branch target PC computation for branches and JAL
         $br_tgt_pc[31:0] = $imm[31:0] + $pc[31:0];
         
         //RAW dependence check for ALU data forwarding
         //If previous instruction was writing to reg file, and current instruction is reading from same register
         $rs1_bypass = >>1$rf_wr_en && (>>1$rd == $rs1);
         $rs2_bypass = >>1$rf_wr_en && (>>1$rd == $rs2);
         
      @3
         //ALU
         $result[31:0] = $is_addi  ? $src1_value +  $imm :
                         $is_add   ? $src1_value +  $src2_value :
                         $is_andi  ? $src1_value &  $imm :
                         $is_ori   ? $src1_value |  $imm :
                         $is_xori  ? $src1_value ^  $imm :
                         $is_slli  ? $src1_value << $imm[5:0]:
                         $is_srli  ? $src1_value >> $imm[5:0]:
                         $is_and   ? $src1_value &  $src2_value:
                         $is_or    ? $src1_value |  $src2_value:
                         $is_xor   ? $src1_value ^  $src2_value:
                         $is_sub   ? $src1_value -  $src2_value:
                         $is_sll   ? $src1_value << $src2_value:
                         $is_srl   ? $src1_value >> $src2_value:
                         $is_sltu  ? $sltu_rslt[31:0]:
                         $is_sltiu ? $sltiu_rslt[31:0]:
                         $is_lui   ? {$imm[31:12], 12'b0}:
                         $is_auipc ? $pc + $imm:
                         $is_jal   ? $pc + 4:
                         $is_jalr  ? $pc + 4:
                         $is_srai  ? ({ {32{$src1_value[31]}} , $src1_value} >> $imm[4:0]) :
                         $is_slt   ? (($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]}):
                         $is_slti  ? (($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]}) :
                         $is_sra   ? ({ {32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $is_load  ? $src1_value +  $imm :
                         $is_s_instr ? $src1_value + $imm :
                                    32'bx;
         
         $sltu_rslt[31:0]  = $src1_value <  $src2_value;
         $sltiu_rslt[31:0] = $src1_value <  $imm;
         
         //Jump instruction target PC computation
         $jalr_tgt_pc[31:0] = $imm[31:0] + $src1_value[31:0]; 
         
         //Branch resolution
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         //Current instruction is valid if one of the previous 2 instructions were not (taken_branch or load or jump)
         $valid = ~(>>1$valid_taken_br || >>2$valid_taken_br || >>1$is_load || >>2$is_load || >>2$jump_valid || >>1$jump_valid);
         
         //Current instruction is valid & is a taken branch
         $valid_taken_br = $valid && $taken_br;
         
         //Current instruction is valid & is a load
         $valid_load = $valid && $is_load;
         
         //Current instruction is valid & is jump
         $jump_valid = $valid && $is_jump;
         $jal_valid  = $valid && $is_jal;
         $jalr_valid = $valid && $is_jalr;
         
         //Destination register update - ALU result or load result depending on instruction
         $rf_wr_en = (($rd != '0) && $rd_valid && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = $valid ? $rd[4:0] : >>2$rd[4:0];
         $rf_wr_data[31:0] = $valid ? $result[31:0] : >>2$ld_data[31:0];
         
      @4
         //Data memory access for load, store
         $dmem_addr[3:0]     =  $result[5:2];
         $dmem_wr_en         =  $valid && $is_s_instr;
         $dmem_wr_data[31:0] =  $src2_value[31:0];
         $dmem_rd_en         =  $valid_load;
         
      
         //Write back data read from load instruction to register
         $ld_data[31:0]      =  $dmem_rd_data[31:0];
         
      
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //Checks if sum of numbers from 1 to 9 is obtained in reg[17] and runs 10 cycles extra after this is met
   *passed = |cpu/xreg[17]>>10$value == (1+2+3+4+5+6+7+8+9);
   //Run for 200 cycles without any checks
   //*passed = *cyc_cnt > 200;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule

  ```

 ![Screenshot (251)](https://github.com/user-attachments/assets/832945f5-847b-4a04-adbe-a54be166139d)

 ![Screenshot 2024-08-22 132714](https://github.com/user-attachments/assets/bc40ea6f-560c-49b4-bf5d-5512f2ee14bc)

  </details>

</details>



***



<details>
  <summary>LAB 6:  TL-Verilog to Verilog Conversion and Waveform Verification with GTKWave and Markerchip</summary>

  In this lab, we will convert the TLV code from our previous lab into Verilog using Python's Sandpiper-SaaS library. Once the conversion is complete, we'll develop a Verilog testbench to compare the waveforms generated by the MakerChip platform with those produced by the Verilog code in gtkwave.

Here are the steps required to convert TLV code to Verilog:

### Installation of necessary tools
Run the following commands in Ubuntu

**1. Install required packages**
```
 $ sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io
 $ sudo chmod 666 /var/run/docker.sock
 $ cd ~
 $ pip3 install pyyaml click sandpiper-saas
```
alternative commands
```
 $ sudo apt install make python python3 python3-pip git iverilog gtkwave
 $ sudo apt-get install python3-venv
 $ python3 -m venv .venv
 $ source ~/.venv/bin/activate
 $ pip3 install pyyaml click sandpiper-saas
```

**2. Clone the repository**
```
 $ cd
 $ git clone https://github.com/manili/VSDBabySoC.git
```

**3. Conversion of TL-Verilog code into Standard Verilog Code**
- __[TL-Verilog Code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv.tlv)__
  Place the TL-Verilog code provided into the VSDBabySoC/src/module directory
```
 $ cd VSDBabySoC
 $ sandpiper-saas -i ./src/module/*.tlv -o likith_riscv.v --bestsv --noline -p verilog --outdir ./src/module/
```
![Screenshot from 2024-08-27 00-39-01](https://github.com/user-attachments/assets/ff870aea-bdbb-48ea-b108-a57936ce323d)


**4. Run the Verilog code using iverilog**
  - __[Converted verilog code](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv.v)__
  - __[Testbench](https://github.com/thelikith/asic-design-class/blob/main/Codes/Lab%206/likith_riscv_tb.v)__
    Place the test bench provided into the VSDBabySoC/src/module directory
```
 $ make pre_synth_sim 
 $ iverilog -o output/likith_riscv.out src/module/likith_riscv_tb.v -I src/include -I src/module
```
 If you encounter the following error, use this command:
 ![Screenshot from 2024-08-27 00-39-50](https://github.com/user-attachments/assets/56ea2bc8-9543-4321-a07f-df2847aecee4)

```
 $ iverilog -o output/likith_riscv.out -g2005-sv src/module/likith_riscv_tb.v -I src/include -I src/module
```

**5. Viewing waveforms in gtkwave**
```
 $ cd output
 $ ./likith_riscv.out
 $ gtkwave likith_riscv.vcd
```
**GTKWave:**
![Screenshot from 2024-08-27 02-51-21](https://github.com/user-attachments/assets/4dd9e539-5b01-4dea-b3c4-89417677bdf7)

**Makerchip:**
![Screenshot 2024-08-22 132714](https://github.com/user-attachments/assets/03bef1df-f7fa-47b8-a61e-51d67abe599f)

We successfully converted TLV code to Verilog using the Sandpiper-SaaS library and verified it by comparing waveforms from the MakerChip platform with those from the Verilog testbench in GTKWave

</details>


***


<details>
  <summary>LAB 7:  BabySoc Pre-synthesis simulation using iverilog GTKwave</summary>

Converting a digital output from a CPU into an analog signal using a DAC (Digital-to-Analog Converter) and PLL (Phase-Locked Loop)

**1. Clone the repository**
```
 $ cd
 $ git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation
```

```
$ iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
$ ./pre_synth_sim.out
$ gtkwave pre_synth_sim.vcd
```



![Screenshot from 2024-09-01 20-29-55](https://github.com/user-attachments/assets/15ec732a-4d8b-4ba3-bee4-89fe1646a923)

#### PLL input and DAC Output
![Screenshot from 2024-09-01 20-28-29](https://github.com/user-attachments/assets/32aaca0f-8fac-47d8-af91-941817052c76)
![Screenshot from 2024-09-01 20-27-49](https://github.com/user-attachments/assets/10cce90c-48ff-4197-92d5-57e23ad9c4f8)
  

  


</details>



